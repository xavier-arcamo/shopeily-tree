<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Worldbuilding Family Tree Builder (Offline)</title>
  <style>
    :root {
      --bg:#0b0f14;
      --panel:#121923;
      --panel2:#0f151e;
      --text:#e7eef8;
      --muted:#9bb0c7;
      --accent:#6ee7ff;
      --danger:#ff6e8a;
      --ok:#7CFFA6;
      --border:#223145;
      --tree-bg:#0c131c;
      --tree-glow:rgba(110,231,255,.08);
      --node-bg:#111827;
      --node-stroke:#334155;
      --node-highlight:#6ee7ff;
      --node-text:#e7eef8;
      --node-sub:#9bb0c7;
      --edge:#475569;
      --partner:#7c7c7c;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text);}
    a{color:var(--accent)}
    header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#0f1621,#0b0f14);}
    header h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.2px}
    header .right{display:flex;gap:10px;align-items:center}
    .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted);font-size:12px}
    main{display:grid;grid-template-columns: 420px 1fr;min-height:calc(100vh - 56px);}
    @media (max-width: 980px){ main{grid-template-columns: 1fr; } }
    .col{padding:14px 14px 18px; border-right:1px solid var(--border);}
    .col:last-child{border-right:none}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:0;margin-bottom:12px; box-shadow: 0 12px 40px rgba(0,0,0,.25);}
    .panelSummary{
      margin:0;
      padding:12px;
      font-size:13px;
      color:var(--muted);
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.12em;
      cursor:pointer;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .panelSummary::-webkit-details-marker{display:none}
    .panelSummary::after{
      content:"▾";
      font-size:12px;
      color:var(--muted);
    }
    details:not([open]) > .panelSummary::after{content:"▸";}
    .panelBody{padding:0 12px 12px}
    .sectionTitle{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:700;text-transform:uppercase;letter-spacing:.12em}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
    input, select, textarea{
      width:100%; padding:10px 10px; border-radius:10px;
      border:1px solid var(--border); background:var(--panel2); color:var(--text);
      outline:none;
    }
    input[type="color"]{
      padding:0;
      height:38px;
      border-radius:10px;
      overflow:hidden;
    }
    textarea{min-height:80px; resize:vertical}
    button{
      padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:rgba(255,255,255,.04);color:var(--text);cursor:pointer;
    }
    button:hover{border-color:#2e4564}
    button.primary{background:linear-gradient(180deg, rgba(110,231,255,.18), rgba(110,231,255,.06)); border-color: rgba(110,231,255,.35);}
    button.danger{background:linear-gradient(180deg, rgba(255,110,138,.20), rgba(255,110,138,.06)); border-color: rgba(255,110,138,.35);}
    button.ok{background:linear-gradient(180deg, rgba(124,255,166,.20), rgba(124,255,166,.06)); border-color: rgba(124,255,166,.35);}
    .small{font-size:12px;color:var(--muted)}
    .list{max-height:48vh; overflow:auto; padding-right:6px}
    .card{
      border:1px solid var(--border); background:rgba(255,255,255,.02);
      border-radius:12px; padding:10px; margin-bottom:10px;
    }
    .cardTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .name{font-weight:800}
    .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .tag{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);background:rgba(255,255,255,.03)}
    .kvs{display:grid;grid-template-columns: 120px 1fr; gap:6px 10px; margin-top:10px}
    .kvk{color:var(--muted);font-size:12px}
    .kvv{font-size:12px}
    .split{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
    @media (max-width: 980px){ .split{grid-template-columns: 1fr;} }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .toolbar .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .status{font-size:12px;color:var(--muted)}
    .hr{height:1px;background:var(--border);margin:10px 0}
    .twoCol{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
    @media (max-width: 980px){ .twoCol{grid-template-columns: 1fr;} }
    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .warn{color:#ffd58a}
    .treeWrap{
      position:relative;
      height:420px;
      border-radius:12px;
      background:radial-gradient(circle at 20% 20%, var(--tree-glow), transparent 45%), var(--tree-bg);
      border:1px solid var(--border);
      overflow:hidden;
    }
    .treeCanvas{
      width:100%;
      height:100%;
      cursor:grab;
      touch-action:none;
    }
    .treeCanvas.dragging{cursor:grabbing}
    .treeControls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .treeHint{font-size:12px;color:var(--muted);margin-top:8px}
    .treeLegend{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .legendItem{display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)}
    .legendButton{
      background:none;
      border:1px solid transparent;
      padding:4px 6px;
      border-radius:8px;
      cursor:pointer;
    }
    .legendButton:hover{
      border-color:var(--border);
      color:var(--text);
    }
    .legendSwatch{width:12px;height:12px;border-radius:4px;border:1px solid rgba(255,255,255,.2)}
    .nodeCard{
      fill:var(--node-bg);
      stroke:var(--node-stroke);
      stroke-width:1;
    }
    .nodeHighlight{
      stroke:var(--node-highlight);
      stroke-width:1.5;
    }
    .edgeLine{
      stroke:var(--edge);
      stroke-width:1.2;
      fill:none;
      stroke-linejoin:miter;
      stroke-linecap:square;
    }
    .partnerLine{
      stroke:var(--partner);
      stroke-width:1;
      stroke-dasharray:5 4;
      opacity:.7;
      fill:none;
      stroke-linejoin:miter;
      stroke-linecap:square;
    }
    .nodeLabel{
      font-size:11px;
      fill:var(--node-text);
      pointer-events:none;
    }
    .nodeSub{
      font-size:10px;
      fill:var(--node-sub);
      pointer-events:none;
    }
    .themeGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 980px){ .themeGrid{grid-template-columns: 1fr;} }
    .themeField{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.02);
    }
    .themeField span{
      font-size:12px;
      color:var(--muted);
      min-width:92px;
    }
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .modal.is-open{display:flex}
    .modalBackdrop{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.5);
    }
    .modalPanel{
      position:relative;
      z-index:1;
      width:min(420px, 92vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:0 20px 50px rgba(0,0,0,.35);
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:12px;
    }
    .modalTitle{
      font-size:14px;
      font-weight:700;
      margin:0;
    }
    .colorPreview{
      width:100%;
      height:36px;
      border-radius:10px;
      border:1px solid var(--border);
      margin-bottom:12px;
    }
    .sliderRow{
      display:grid;
      grid-template-columns: 60px 1fr 60px;
      gap:8px;
      align-items:center;
      margin-bottom:8px;
      font-size:12px;
      color:var(--muted);
    }
    .sliderRow input[type="range"]{
      width:100%;
    }
  </style>
</head>
<body>
<header>
  <h1>Worldbuilding Family Tree Builder</h1>
  <div class="right">
    <div class="pill" id="countPill">0 people</div>
    <button class="ok" id="btnSave">Save</button>
    <button class="danger" id="btnReset">Reset</button>
  </div>
</header>

<main>
  <!-- LEFT: Create/Search/List -->
  <section class="col">
    <details class="panel" open>
      <summary class="panelSummary">Create Person</summary>
      <div class="panelBody">
      <div class="row">
        <div>
          <label>Name *</label>
          <input id="pName" placeholder="e.g., Aurelian Voss" />
        </div>
        <div>
          <label>Sex/Gender</label>
          <select id="pSex">
            <option value="">(unspecified)</option>
            <option value="M">M</option>
            <option value="F">F</option>
            <option value="X">X / other</option>
          </select>
        </div>
      </div>
      <div class="twoCol">
        <div>
          <label>Birth (string)</label>
          <input id="pBirth" placeholder="e.g., 982 AE / Winter / 3rd Moon" />
        </div>
        <div>
          <label>Death (string)</label>
          <input id="pDeath" placeholder="optional" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>House/Clan</label>
          <input id="pHouse" placeholder="e.g., House Voss" />
        </div>
        <div>
          <label>Titles (comma-separated)</label>
          <input id="pTitles" placeholder="e.g., Archon, Sword-Saint" />
        </div>
      </div>
      <label>Notes</label>
      <textarea id="pNotes" placeholder="Lore notes, personality, plot hooks…"></textarea>
      <div class="row">
        <button class="primary" id="btnAdd">Add Person</button>
        <button id="btnAddAndSelect">Add + Select</button>
      </div>
      <div class="hint">
        Tip: Birth/Death are freeform so you can use your own calendar (AE, regnal years, etc.).
      </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Search & People</summary>
      <div class="panelBody">
      <label>Search</label>
      <input id="q" placeholder="name, house, title…" />
      <div class="toolbar" style="margin-top:10px">
        <div class="left">
          <button id="btnSortName">Sort: Name</button>
          <button id="btnSortHouse">Sort: House</button>
        </div>
        <div class="status" id="status">Autosave: on</div>
      </div>
      <div class="hr"></div>
      <div class="list" id="peopleList"></div>
      <div class="hint">
        Click a person to edit & link relationships.
      </div>
      </div>
    </details>
  </section>

  <!-- RIGHT: Detail / Relationships / Export -->
  <section class="col">
    <details class="panel" id="detailPanel" open>
      <summary class="panelSummary">Selected Person</summary>
      <div class="panelBody" id="detailBody">
        <div class="small">No person selected.</div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Tree View</summary>
      <div class="panelBody">
      <div class="toolbar" style="margin-bottom:8px">
        <div class="left treeControls">
          <button id="btnZoomIn">Zoom +</button>
          <button id="btnZoomOut">Zoom −</button>
          <button id="btnZoomReset">Reset View</button>
        </div>
        <div class="status" id="treeStatus">Zoom 100%</div>
      </div>
      <div class="treeWrap">
        <svg id="treeSvg" class="treeCanvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet">
          <g id="treeViewport">
            <rect x="-6000" y="-6000" width="12000" height="12000" fill="transparent"></rect>
          </g>
        </svg>
      </div>
      <div class="treeHint">
        Drag to pan. Scroll or pinch to zoom. Click a card to select.
      </div>
      <div class="treeLegend" id="treeLegend"></div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Theme Studio</summary>
      <div class="panelBody">
      <div class="row">
        <div>
          <label>Preset</label>
          <select id="themePreset"></select>
        </div>
        <div style="display:flex;gap:10px;align-items:flex-end">
          <button id="btnApplyPreset" class="primary">Apply Preset</button>
          <button id="btnResetTheme">Reset</button>
        </div>
      </div>
      <div class="themeGrid" id="themeGrid"></div>
      <div class="hint" style="margin-top:10px">
        Adjust colors to instantly re-skin the workspace and tree. Changes are saved locally.
      </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Export / Import</summary>
      <div class="panelBody">

      <div class="split">
        <div>
          <label>Format</label>
          <select id="exportFormat">
            <option value="json">JSON (recommended)</option>
            <option value="yaml">YAML</option>
            <option value="dot">Graphviz DOT</option>
            <option value="mermaid">Mermaid (graph TD)</option>
            <option value="gedcom">GEDCOM (basic)</option>
          </select>
        </div>
        <div style="display:flex;gap:10px;align-items:flex-end">
          <button class="primary" id="btnExport">Generate Export</button>
          <button id="btnCopy">Copy</button>
          <button id="btnDownload">Download</button>
        </div>
      </div>

      <label>Export Output</label>
      <textarea id="out" class="mono" placeholder="Click “Generate Export” …"></textarea>

      <div class="hr"></div>

      <label>Import (JSON)</label>
      <textarea id="importBox" class="mono" placeholder='Paste JSON export here, then click “Import JSON”'></textarea>
      <div class="row">
        <button class="ok" id="btnImport">Import JSON</button>
        <button id="btnMergeImport">Merge JSON (keep existing)</button>
      </div>

      <div class="hint">
        <span class="warn">Note:</span> GEDCOM export is “lite” (enough for many tools, but not full fidelity for fantasy calendars).
        For maximum interoperability, use JSON as your source of truth, then generate DOT/Mermaid for visuals.
      </div>
      </div>
    </details>
  </section>
</main>

<div class="modal" id="houseColorModal" aria-hidden="true">
  <div class="modalBackdrop" data-action="close-house-color"></div>
  <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="houseColorTitle">
    <div class="modalHeader">
      <h2 class="modalTitle" id="houseColorTitle">Edit House Color</h2>
      <button id="houseColorClose">Close</button>
    </div>
    <div class="colorPreview" id="houseColorPreview"></div>
    <label>Hex</label>
    <input id="houseColorHex" placeholder="#AABBCC" class="mono" />
    <div class="row" style="margin-top:10px">
      <div>
        <label>Picker</label>
        <input type="color" id="houseColorPicker" />
      </div>
      <div>
        <label>Reset</label>
        <button id="houseColorReset">Default Palette</button>
      </div>
    </div>
    <div class="sectionTitle" style="margin-top:12px">RGB Sliders</div>
    <div class="sliderRow">
      <span>R</span>
      <input type="range" min="0" max="255" id="houseColorR" />
      <span id="houseColorRValue">0</span>
    </div>
    <div class="sliderRow">
      <span>G</span>
      <input type="range" min="0" max="255" id="houseColorG" />
      <span id="houseColorGValue">0</span>
    </div>
    <div class="sliderRow">
      <span>B</span>
      <input type="range" min="0" max="255" id="houseColorB" />
      <span id="houseColorBValue">0</span>
    </div>
    <div class="hint" style="margin-top:10px">
      Tip: Changes apply instantly to the tree and legend.
    </div>
  </div>
</div>

<script>
/** ===========================
 *  Data model
 *  ===========================
 *  store = {
 *    people: {
 *      [id]: {
 *        id, name, sex, birth, death, house,
 *        titles: string[],
 *        notes: string,
 *        parents: string[],   // up to 2 typically, but we don't enforce
 *        partners: string[],  // spouses/partners
 *        children: string[]   // derived or manual; we keep it explicit for performance on large trees
 *      }
 *    },
 *    meta: { version, updatedAt }
 *  }
 */
const STORAGE_KEY = "wb_family_tree_v1";
const THEME_KEY = "wb_family_tree_theme_v1";
const HOUSE_COLOR_KEY = "wb_family_tree_house_colors_v1";
const BLOODLINE_DEFAULT_SLOTS = {
  Drake: 12,
  Moon: 12
};
const BLOODLINE_DEFAULT_SETTINGS = {
  mutationRate: 0.01,
  reinforcementRate: 0,
  latentThreshold: 0.6,
  enableLatent: false,
  totalStrengthCap: null
};
let store = normalizeStore(loadStore() ?? freshStore());
let selectedId = null;
let sortMode = "name";
let currentTheme = loadTheme();
let houseColorOverrides = loadHouseColorOverrides();

function freshStore(){
  return {
    people: {},
    meta: withDefaultBloodlineMeta({ version: 2, updatedAt: new Date().toISOString() })
  };
}
function uid(){
  // short stable-ish id: p_ + 10 chars
  return "p_" + Math.random().toString(36).slice(2, 12);
}
function saveStore(){
  store.meta.updatedAt = new Date().toISOString();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
  render();
}
function loadStore(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    // basic shape check
    if(!parsed || typeof parsed !== "object" || !parsed.people) return null;
    return normalizeStore(parsed);
  }catch{ return null; }
}

function normalizeStore(candidate){
  if(!candidate || typeof candidate !== "object") return freshStore();
  const normalized = candidate;
  normalized.people = normalized.people || {};
  normalized.meta = withDefaultBloodlineMeta(normalized.meta || {});
  return normalized;
}

function withDefaultBloodlineMeta(meta){
  const next = { ...meta };
  next.version = next.version || 2;
  next.bloodlineSlots = {
    ...BLOODLINE_DEFAULT_SLOTS,
    ...(next.bloodlineSlots || {})
  };
  next.bloodlineSettings = {
    ...BLOODLINE_DEFAULT_SETTINGS,
    ...(next.bloodlineSettings || {})
  };
  return next;
}

function personById(id){ return store.people[id] || null; }

function getBloodlineSlots(){
  return store?.meta?.bloodlineSlots || { ...BLOODLINE_DEFAULT_SLOTS };
}

function getBloodlineSettings(){
  return store?.meta?.bloodlineSettings || { ...BLOODLINE_DEFAULT_SETTINGS };
}

function defaultTheme(){
  return {
    name: "Obsidian Glow",
    values: {
      "--bg":"#0b0f14",
      "--panel":"#121923",
      "--panel2":"#0f151e",
      "--text":"#e7eef8",
      "--muted":"#9bb0c7",
      "--accent":"#6ee7ff",
      "--danger":"#ff6e8a",
      "--ok":"#7CFFA6",
      "--border":"#223145",
      "--tree-bg":"#0c131c",
      "--tree-glow":"rgba(110,231,255,.08)",
      "--node-bg":"#111827",
      "--node-stroke":"#334155",
      "--node-highlight":"#6ee7ff",
      "--node-text":"#e7eef8",
      "--node-sub":"#9bb0c7",
      "--edge":"#475569",
      "--partner":"#7c7c7c"
    }
  };
}

const themePresets = [
  defaultTheme(),
  {
    name: "Sunlit Canvas",
    values: {
      "--bg":"#f5f7fb",
      "--panel":"#ffffff",
      "--panel2":"#f0f3f8",
      "--text":"#1f2937",
      "--muted":"#5b6b7f",
      "--accent":"#2563eb",
      "--danger":"#dc2626",
      "--ok":"#16a34a",
      "--border":"#d6dde8",
      "--tree-bg":"#f1f5f9",
      "--tree-glow":"rgba(37,99,235,.12)",
      "--node-bg":"#ffffff",
      "--node-stroke":"#cbd5e1",
      "--node-highlight":"#2563eb",
      "--node-text":"#1f2937",
      "--node-sub":"#5b6b7f",
      "--edge":"#94a3b8",
      "--partner":"#94a3b8"
    }
  },
  {
    name: "Mist & Ink",
    values: {
      "--bg":"#eef1f6",
      "--panel":"#f9fafb",
      "--panel2":"#e5e9f1",
      "--text":"#1f2933",
      "--muted":"#526070",
      "--accent":"#0f766e",
      "--danger":"#b91c1c",
      "--ok":"#15803d",
      "--border":"#cbd4e1",
      "--tree-bg":"#e8edf4",
      "--tree-glow":"rgba(15,118,110,.14)",
      "--node-bg":"#ffffff",
      "--node-stroke":"#bcc7d6",
      "--node-highlight":"#0f766e",
      "--node-text":"#1f2933",
      "--node-sub":"#526070",
      "--edge":"#8b98aa",
      "--partner":"#8b98aa"
    }
  },
  {
    name: "Verdant Archive",
    values: {
      "--bg":"#0a0f0c",
      "--panel":"#111a14",
      "--panel2":"#0d1511",
      "--text":"#e6f2ea",
      "--muted":"#9bb7a2",
      "--accent":"#7efcc5",
      "--danger":"#ff8aa1",
      "--ok":"#9bffb5",
      "--border":"#1f3527",
      "--tree-bg":"#0d1511",
      "--tree-glow":"rgba(126,252,197,.10)",
      "--node-bg":"#111f17",
      "--node-stroke":"#2b4a36",
      "--node-highlight":"#7efcc5",
      "--node-text":"#e6f2ea",
      "--node-sub":"#9bb7a2",
      "--edge":"#3a5a46",
      "--partner":"#6fa988"
    }
  },
  {
    name: "Solar Ember",
    values: {
      "--bg":"#130b0b",
      "--panel":"#1b1110",
      "--panel2":"#150d0c",
      "--text":"#ffe9dc",
      "--muted":"#c8a79a",
      "--accent":"#ffb347",
      "--danger":"#ff7a7a",
      "--ok":"#ffd166",
      "--border":"#3d2420",
      "--tree-bg":"#170f0d",
      "--tree-glow":"rgba(255,179,71,.12)",
      "--node-bg":"#221211",
      "--node-stroke":"#56342b",
      "--node-highlight":"#ffb347",
      "--node-text":"#ffe9dc",
      "--node-sub":"#c8a79a",
      "--edge":"#7b4a3d",
      "--partner":"#b77b5d"
    }
  },
  {
    name: "Arcane Frost",
    values: {
      "--bg":"#0a0d13",
      "--panel":"#121823",
      "--panel2":"#0f141f",
      "--text":"#e9f1ff",
      "--muted":"#a5b8d6",
      "--accent":"#9ad0ff",
      "--danger":"#ff8fb1",
      "--ok":"#9af1ff",
      "--border":"#223147",
      "--tree-bg":"#0c111b",
      "--tree-glow":"rgba(154,208,255,.12)",
      "--node-bg":"#111825",
      "--node-stroke":"#2f3f57",
      "--node-highlight":"#9ad0ff",
      "--node-text":"#e9f1ff",
      "--node-sub":"#a5b8d6",
      "--edge":"#4a5b78",
      "--partner":"#7d90b5"
    }
  }
];

function loadTheme(){
  try{
    const raw = localStorage.getItem(THEME_KEY);
    if(!raw) return defaultTheme();
    const parsed = JSON.parse(raw);
    if(!parsed || !parsed.values) return defaultTheme();
    const base = defaultTheme();
    return {
      name: parsed.name || base.name,
      values: { ...base.values, ...parsed.values }
    };
  }catch{
    return defaultTheme();
  }
}

function saveTheme(){
  localStorage.setItem(THEME_KEY, JSON.stringify(currentTheme));
}

function applyTheme(theme){
  const root = document.documentElement;
  Object.entries(theme.values).forEach(([key, value]) => {
    root.style.setProperty(key, value);
  });
}

function loadHouseColorOverrides(){
  try{
    const raw = localStorage.getItem(HOUSE_COLOR_KEY);
    if(!raw) return {};
    const parsed = JSON.parse(raw);
    if(!parsed || typeof parsed !== "object") return {};
    return parsed;
  }catch{
    return {};
  }
}

function saveHouseColorOverrides(){
  localStorage.setItem(HOUSE_COLOR_KEY, JSON.stringify(houseColorOverrides));
}

function normalizeTitles(s){
  return (s || "")
    .split(",")
    .map(x => x.trim())
    .filter(Boolean);
}
function safeName(p){ return (p?.name || "").trim() || "(unnamed)"; }

function addPerson({
  name,
  sex,
  birth,
  death,
  house,
  titles,
  notes,
  parents = [],
  bloodlineStrengths = null,
  rng = Math.random
}){
  const id = uid();
  const person = {
    id,
    name: (name || "").trim(),
    sex: sex || "",
    birth: birth || "",
    death: death || "",
    house: house || "",
    titles: titles || [],
    notes: notes || "",
    parents: [],
    partners: [],
    children: [],
    bloodlines: {},
    bloodlinesAuto: false
  };
  if(bloodlineStrengths && typeof bloodlineStrengths === "object"){
    person.bloodlines = seedBloodlinesFromStrengths(bloodlineStrengths, rng);
    person.bloodlinesAuto = false;
  }
  store.people[id] = person;
  if(Array.isArray(parents) && parents.length){
    parents.filter(Boolean).forEach(parentId => linkParentChild(parentId, id));
    applyBloodlinesFromParents(id);
  }
  return id;
}

function removeIdFromArray(arr, id){
  const i = arr.indexOf(id);
  if(i >= 0) arr.splice(i,1);
}

function linkParentChild(parentId, childId){
  const parent = personById(parentId);
  const child = personById(childId);
  if(!parent || !child) return;

  if(!parent.children.includes(childId)) parent.children.push(childId);
  if(!child.parents.includes(parentId)) child.parents.push(parentId);
  applyBloodlinesFromParents(childId);
}

function unlinkParentChild(parentId, childId){
  const parent = personById(parentId);
  const child = personById(childId);
  if(!parent || !child) return;

  removeIdFromArray(parent.children, childId);
  removeIdFromArray(child.parents, parentId);
}

function seedBloodlinesFromStrengths(strengths, rng = Math.random){
  const slots = getBloodlineSlots();
  const result = {};
  Object.entries(strengths || {}).forEach(([bloodline, strength]) => {
    const slotCount = slots[bloodline];
    if(!slotCount) return;
    result[bloodline] = createTokensFromStrength(strength, slotCount, rng);
  });
  return result;
}

function createTokensFromStrength(strength, slots, rng = Math.random){
  const clamped = Math.max(0, Math.min(1, Number(strength) || 0));
  const ones = Math.round(clamped * slots);
  const indices = [...Array(slots).keys()];
  shuffleInPlace(indices, rng);
  const tokens = Array(slots).fill(0);
  for(let i = 0; i < ones; i += 1){
    tokens[indices[i]] = 1;
  }
  return tokens;
}

function shuffleInPlace(arr, rng = Math.random){
  for(let i = arr.length - 1; i > 0; i -= 1){
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function computeBloodlineStrength(tokens){
  if(!Array.isArray(tokens) || tokens.length === 0) return 0;
  const ones = tokens.reduce((sum, val) => sum + (val ? 1 : 0), 0);
  return ones / tokens.length;
}

function getBloodlineStrength(person, bloodline){
  return computeBloodlineStrength(person?.bloodlines?.[bloodline]);
}

function normalizeTokens(tokens, slots){
  const normalized = Array.isArray(tokens) ? tokens.slice(0, slots).map(v => (v ? 1 : 0)) : [];
  while(normalized.length < slots) normalized.push(0);
  return normalized;
}

function getBloodlineSlotCount(name, parentA, parentB){
  const slots = getBloodlineSlots();
  if(slots[name]) return slots[name];
  const tokensA = parentA?.bloodlines?.[name];
  const tokensB = parentB?.bloodlines?.[name];
  return tokensA?.length || tokensB?.length || null;
}

function inheritBloodlines({
  parentA,
  parentB,
  mutationRate = 0,
  reinforcementRate = 0,
  rng = Math.random
}){
  const names = new Set([
    ...Object.keys(getBloodlineSlots()),
    ...Object.keys(parentA?.bloodlines || {}),
    ...Object.keys(parentB?.bloodlines || {})
  ]);
  const result = {};
  for(const bloodline of names){
    const slotCount = getBloodlineSlotCount(bloodline, parentA, parentB);
    if(!slotCount) continue;
    const tokensA = parentA?.bloodlines?.[bloodline];
    const tokensB = parentB?.bloodlines?.[bloodline];
    if(!tokensA && !tokensB) continue;
    const parentTokensA = tokensA ? normalizeTokens(tokensA, slotCount) : Array(slotCount).fill(0);
    const parentTokensB = tokensB ? normalizeTokens(tokensB, slotCount) : Array(slotCount).fill(0);
    const childTokens = [];
    for(let i = 0; i < slotCount; i += 1){
      let inherited = rng() < 0.5 ? parentTokensA[i] : parentTokensB[i];
      if(reinforcementRate > 0 && parentTokensA[i] === 1 && parentTokensB[i] === 1 && rng() < reinforcementRate){
        inherited = 1;
      }
      if(mutationRate > 0 && rng() < mutationRate){
        inherited = inherited ? 0 : 1;
      }
      childTokens.push(inherited);
    }
    result[bloodline] = childTokens;
  }
  return result;
}

function hasBloodlines(person){
  return person && person.bloodlines && Object.keys(person.bloodlines).length > 0;
}

function applyBloodlinesFromParents(childId, { force = false } = {}){
  const child = personById(childId);
  if(!child) return;
  const parents = (child.parents || []).map(id => personById(id)).filter(Boolean);
  if(parents.length === 0) return;
  if(!force && hasBloodlines(child) && !child.bloodlinesAuto) return;
  const settings = getBloodlineSettings();
  const inherited = inheritBloodlines({
    parentA: parents[0] || null,
    parentB: parents[1] || null,
    mutationRate: settings.mutationRate,
    reinforcementRate: settings.reinforcementRate
  });
  if(Object.keys(inherited).length){
    child.bloodlines = inherited;
    child.bloodlinesAuto = true;
  }
}

function linkPartners(aId, bId){
  const a = personById(aId);
  const b = personById(bId);
  if(!a || !b || aId === bId) return;
  if(!a.partners.includes(bId)) a.partners.push(bId);
  if(!b.partners.includes(aId)) b.partners.push(aId);
}

function unlinkPartners(aId, bId){
  const a = personById(aId);
  const b = personById(bId);
  if(!a || !b) return;
  removeIdFromArray(a.partners, bId);
  removeIdFromArray(b.partners, aId);
}

function deletePerson(id){
  const p = personById(id);
  if(!p) return;

  // remove relationships from others
  for(const otherId of Object.keys(store.people)){
    const o = store.people[otherId];
    removeIdFromArray(o.parents, id);
    removeIdFromArray(o.children, id);
    removeIdFromArray(o.partners, id);
  }
  delete store.people[id];
  if(selectedId === id) selectedId = null;
}

/** ===========================
 *  Rendering
 *  =========================== */
const el = (id) => document.getElementById(id);

function render(){
  // count
  el("countPill").textContent = `${Object.keys(store.people).length} people`;

  // list
  renderPeopleList();

  // detail
  renderDetail();

  // tree
  renderTree();
}

function peopleArrayFiltered(){
  const q = (el("q").value || "").trim().toLowerCase();
  let arr = Object.values(store.people);

  if(q){
    arr = arr.filter(p => {
      const hay = [
        p.name, p.house, (p.titles||[]).join(" "), p.birth, p.death, p.notes
      ].join(" ").toLowerCase();
      return hay.includes(q);
    });
  }

  arr.sort((a,b) => {
    if(sortMode === "house"){
      const ha = (a.house||"").toLowerCase();
      const hb = (b.house||"").toLowerCase();
      if(ha !== hb) return ha.localeCompare(hb);
    }
    return safeName(a).toLowerCase().localeCompare(safeName(b).toLowerCase());
  });

  return arr;
}

function renderPeopleList(){
  const list = el("peopleList");
  list.innerHTML = "";

  const arr = peopleArrayFiltered();
  for(const p of arr){
    const div = document.createElement("div");
    div.className = "card";
    div.style.borderColor = (p.id === selectedId) ? "rgba(110,231,255,.45)" : "var(--border)";
    div.innerHTML = `
      <div class="cardTop">
        <div>
          <div class="name">${escapeHtml(safeName(p))}</div>
          <div class="small">${escapeHtml(p.house || "")}${p.house && p.birth ? " • " : ""}${escapeHtml(p.birth || "")}</div>
          <div class="tags">
            ${(p.titles||[]).slice(0,6).map(t => `<span class="tag">${escapeHtml(t)}</span>`).join("")}
            ${(p.titles||[]).length>6 ? `<span class="tag">+${(p.titles||[]).length-6}</span>` : ""}
          </div>
        </div>
        <div style="display:flex;gap:8px">
          <button data-act="select" data-id="${p.id}">Select</button>
        </div>
      </div>
    `;
    div.querySelector('[data-act="select"]').onclick = () => { selectedId = p.id; render(); };
    list.appendChild(div);
  }

  if(arr.length === 0){
    list.innerHTML = `<div class="small">No results.</div>`;
  }
}

function renderDetail(){
  const panel = el("detailBody");
  const p = selectedId ? personById(selectedId) : null;
  if(!p){
    panel.innerHTML = `<div class="small">No person selected.</div>`;
    return;
  }

  // build dropdown options (exclude selected)
  const options = Object.values(store.people)
    .filter(x => x.id !== p.id)
    .sort((a,b)=>safeName(a).localeCompare(safeName(b)))
    .map(x => `<option value="${x.id}">${escapeHtml(safeName(x))}${x.house ? " — " + escapeHtml(x.house) : ""}</option>`)
    .join("");

  const parents = (p.parents||[]).map(id => personById(id)).filter(Boolean);
  const partners = (p.partners||[]).map(id => personById(id)).filter(Boolean);
  const children = (p.children||[]).map(id => personById(id)).filter(Boolean);

  panel.innerHTML = `
    <div class="row">
      <div>
        <label>Name</label>
        <input id="eName" value="${escapeAttr(p.name)}" />
      </div>
      <div>
        <label>Sex/Gender</label>
        <select id="eSex">
          <option value="" ${p.sex===""?"selected":""}>(unspecified)</option>
          <option value="M" ${p.sex==="M"?"selected":""}>M</option>
          <option value="F" ${p.sex==="F"?"selected":""}>F</option>
          <option value="X" ${p.sex==="X"?"selected":""}>X / other</option>
        </select>
      </div>
    </div>

    <div class="twoCol">
      <div>
        <label>Birth</label>
        <input id="eBirth" value="${escapeAttr(p.birth||"")}" />
      </div>
      <div>
        <label>Death</label>
        <input id="eDeath" value="${escapeAttr(p.death||"")}" />
      </div>
    </div>

    <div class="row">
      <div>
        <label>House/Clan</label>
        <input id="eHouse" value="${escapeAttr(p.house||"")}" />
      </div>
      <div>
        <label>Titles (comma-separated)</label>
        <input id="eTitles" value="${escapeAttr((p.titles||[]).join(", "))}" />
      </div>
    </div>

    <label>Notes</label>
    <textarea id="eNotes">${escapeHtml(p.notes||"")}</textarea>

    <div class="row">
      <button class="ok" id="btnUpdate">Update</button>
      <button class="danger" id="btnDelete">Delete Person</button>
    </div>

    <div class="hr"></div>

    <div class="sectionTitle">Relationships</div>

    <div class="split">
      <div class="card" style="margin:0">
        <div class="name">Parents</div>
        <div class="small">${parents.length ? parents.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <select id="relParentSel"><option value="">Choose person…</option>${options}</select>
          <button id="btnAddParent">Add Parent</button>
        </div>
        <div style="margin-top:10px">
          ${parents.map(x => `
            <div class="row" style="align-items:center;margin-top:6px">
              <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
              <button data-unlink-parent="${x.id}" class="danger" style="flex:1">Remove</button>
            </div>
          `).join("")}
        </div>
      </div>

      <div class="card" style="margin:0">
        <div class="name">Partners</div>
        <div class="small">${partners.length ? partners.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <select id="relPartnerSel"><option value="">Choose person…</option>${options}</select>
          <button id="btnAddPartner">Add Partner</button>
        </div>
        <div style="margin-top:10px">
          ${partners.map(x => `
            <div class="row" style="align-items:center;margin-top:6px">
              <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
              <button data-unlink-partner="${x.id}" class="danger" style="flex:1">Remove</button>
            </div>
          `).join("")}
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <div class="name">Children</div>
      <div class="small">${children.length ? children.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>

      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <select id="relChildSel"><option value="">Choose person…</option>${options}</select>
        <button id="btnAddChild">Add Child</button>
      </div>

      <div style="margin-top:10px">
        ${children.map(x => `
          <div class="row" style="align-items:center;margin-top:6px">
            <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
            <button data-unlink-child="${x.id}" class="danger" style="flex:1">Remove</button>
          </div>
        `).join("")}
      </div>

      <div class="hint" style="margin-top:10px">
        “Add Child” links both ways (child ↔ parent). Same for parents and partners.
      </div>
    </div>
  `;

  // hook events
  el("btnUpdate").onclick = () => {
    const p2 = personById(p.id);
    if(!p2) return;
    p2.name = el("eName").value.trim();
    p2.sex = el("eSex").value;
    p2.birth = el("eBirth").value;
    p2.death = el("eDeath").value;
    p2.house = el("eHouse").value;
    p2.titles = normalizeTitles(el("eTitles").value);
    p2.notes = el("eNotes").value;
    saveStore();
  };

  el("btnDelete").onclick = () => {
    if(!confirm(`Delete ${safeName(p)}? This will remove their links too.`)) return;
    deletePerson(p.id);
    saveStore();
  };

  el("btnAddParent").onclick = () => {
    const other = el("relParentSel").value;
    if(!other) return;
    linkParentChild(other, p.id);
    saveStore();
  };

  el("btnAddChild").onclick = () => {
    const other = el("relChildSel").value;
    if(!other) return;
    linkParentChild(p.id, other);
    saveStore();
  };

  el("btnAddPartner").onclick = () => {
    const other = el("relPartnerSel").value;
    if(!other) return;
    linkPartners(p.id, other);
    saveStore();
  };

  panel.querySelectorAll("[data-unlink-parent]").forEach(btn => {
    btn.onclick = () => { unlinkParentChild(btn.getAttribute("data-unlink-parent"), p.id); saveStore(); };
  });
  panel.querySelectorAll("[data-unlink-child]").forEach(btn => {
    btn.onclick = () => { unlinkParentChild(p.id, btn.getAttribute("data-unlink-child")); saveStore(); };
  });
  panel.querySelectorAll("[data-unlink-partner]").forEach(btn => {
    btn.onclick = () => { unlinkPartners(p.id, btn.getAttribute("data-unlink-partner")); saveStore(); };
  });
}

function escapeHtml(s){
  return (s ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}
function escapeAttr(s){
  return escapeHtml(s).replaceAll('"',"&quot;");
}

/** ===========================
 *  Tree view
 *  =========================== */
const treeView = {
  scale: 1,
  x: 0,
  y: 0,
  minScale: 0.4,
  maxScale: 2.4
};

function updateTreeStatus(){
  el("treeStatus").textContent = `Zoom ${Math.round(treeView.scale * 100)}%`;
}

function applyTreeTransform(){
  const g = el("treeViewport");
  g.setAttribute("transform", `translate(${treeView.x} ${treeView.y}) scale(${treeView.scale})`);
  updateTreeStatus();
}

function clampTreeScale(next){
  return Math.min(treeView.maxScale, Math.max(treeView.minScale, next));
}

function clamp(min, max, value){
  return Math.min(max, Math.max(min, value));
}

function resetTreeView(){
  treeView.scale = 1;
  treeView.x = 0;
  treeView.y = 0;
  applyTreeTransform();
}

function buildPartnerGroups(people){
  const parent = new Map();
  const rank = new Map();
  const ids = people.map(p => p.id);
  ids.forEach(id => { parent.set(id, id); rank.set(id, 0); });

  const find = (id) => {
    const root = parent.get(id);
    if(root === id) return id;
    const next = find(root);
    parent.set(id, next);
    return next;
  };
  const union = (a, b) => {
    const ra = find(a);
    const rb = find(b);
    if(ra === rb) return;
    const rankA = rank.get(ra) || 0;
    const rankB = rank.get(rb) || 0;
    if(rankA < rankB) parent.set(ra, rb);
    else if(rankA > rankB) parent.set(rb, ra);
    else { parent.set(rb, ra); rank.set(ra, rankA + 1); }
  };

  for(const p of people){
    for(const partnerId of (p.partners||[])){
      if(store.people[partnerId]) union(p.id, partnerId);
    }
  }

  const groupMap = new Map();
  for(const id of ids){
    const root = find(id);
    if(!groupMap.has(root)) groupMap.set(root, []);
    groupMap.get(root).push(id);
  }

  const groupIdByPerson = new Map();
  const groups = [];
  let idx = 0;
  for(const members of groupMap.values()){
    const groupId = idx++;
    groups.push({ id: groupId, members });
    for(const member of members) groupIdByPerson.set(member, groupId);
  }

  return { groups, groupIdByPerson };
}

function computeGroupLevels(partnerGroups, people){
  const groupCount = partnerGroups.groups.length;
  const edges = new Map();
  const indegree = Array(groupCount).fill(0);
  for(let i=0;i<groupCount;i++) edges.set(i, new Set());

  for(const p of people){
    const fromGroup = partnerGroups.groupIdByPerson.get(p.id);
    for(const childId of (p.children||[])){
      if(!store.people[childId]) continue;
      const toGroup = partnerGroups.groupIdByPerson.get(childId);
      if(fromGroup === toGroup) continue;
      if(!edges.get(fromGroup).has(toGroup)){
        edges.get(fromGroup).add(toGroup);
        indegree[toGroup] += 1;
      }
    }
  }

  const levels = Array(groupCount).fill(0);
  const queue = [];
  indegree.forEach((deg, idx) => { if(deg === 0) queue.push(idx); });
  let visited = 0;
  while(queue.length){
    const g = queue.shift();
    visited += 1;
    for(const to of edges.get(g)){
      if(levels[to] < levels[g] + 1) levels[to] = levels[g] + 1;
      indegree[to] -= 1;
      if(indegree[to] === 0) queue.push(to);
    }
  }

  if(visited < groupCount){
    let changed = true;
    let iterations = 0;
    while(changed && iterations < groupCount * 4){
      changed = false;
      iterations += 1;
      for(const [from, targets] of edges.entries()){
        for(const to of targets){
          if(levels[to] < levels[from] + 1){
            levels[to] = levels[from] + 1;
            changed = true;
          }
        }
      }
    }
  }

  const result = new Map();
  partnerGroups.groups.forEach(group => {
    result.set(group.id, levels[group.id] || 0);
  });
  return result;
}

const housePalette = [
  "#60a5fa",
  "#f472b6",
  "#34d399",
  "#facc15",
  "#a78bfa",
  "#fb7185",
  "#22d3ee",
  "#fb923c",
  "#4ade80",
  "#f97316"
];

function hashString(str){
  let hash = 0;
  for(let i=0;i<str.length;i++){
    hash = (hash * 31 + str.charCodeAt(i)) | 0;
  }
  return Math.abs(hash);
}

function colorForHouse(house){
  const key = (house || "").trim();
  if(!key) return null;
  const idx = hashString(key) % housePalette.length;
  return housePalette[idx];
}

function resolveHouseColor(house){
  const key = (house || "").trim();
  if(!key) return null;
  if(houseColorOverrides[key]) return houseColorOverrides[key];
  return colorForHouse(key);
}

function renderTree(){
  const svg = el("treeSvg");
  const viewport = el("treeViewport");
  viewport.innerHTML = `<rect x="-6000" y="-6000" width="12000" height="12000" fill="transparent"></rect>`;

  const people = Object.values(store.people);
  if(people.length === 0){
    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute("x","0");
    text.setAttribute("y","0");
    text.setAttribute("class","nodeLabel");
    text.textContent = "Add people to see the tree.";
    viewport.appendChild(text);
    applyTreeTransform();
    return;
  }

  const partnerGroups = buildPartnerGroups(people);
  const groupLevels = computeGroupLevels(partnerGroups, people);
  const levels = new Map();
  for(const p of people){
    const d = groupLevels.get(partnerGroups.groupIdByPerson.get(p.id)) || 0;
    if(!levels.has(d)) levels.set(d, []);
    levels.get(d).push(p);
  }
  for(const list of levels.values()){
    list.sort((a,b)=> {
      const ga = partnerGroups.groupIdByPerson.get(a.id);
      const gb = partnerGroups.groupIdByPerson.get(b.id);
      if(ga !== gb) return ga - gb;
      return safeName(a).localeCompare(safeName(b));
    });
  }

  const levelKeys = Array.from(levels.keys()).sort((a,b)=>a-b);
  const maxPerLevel = Math.max(...Array.from(levels.values()).map(list => list.length), 1);
  const dynamicGapX = clamp(40, 90, 110 - maxPerLevel * 6);
  const dynamicGapY = clamp(40, 70, 70 - levelKeys.length * 2);
  const nodeSize = { w: 180, h: 68, gapX: dynamicGapX, gapY: dynamicGapY };
  const positions = new Map();
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for(const level of levelKeys){
    const peopleAt = levels.get(level);
    const totalWidth = peopleAt.length * (nodeSize.w + nodeSize.gapX) - nodeSize.gapX;
    const offsetX = -totalWidth / 2;
    const y = level * (nodeSize.h + nodeSize.gapY);
    peopleAt.forEach((p, i) => {
      const x = offsetX + i * (nodeSize.w + nodeSize.gapX);
      positions.set(p.id, { x, y });
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x + nodeSize.w);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y + nodeSize.h);
    });
  }

  const elbowPath = (start, end, mid) => {
    return `M ${start.x} ${start.y} L ${start.x} ${mid} L ${end.x} ${mid} L ${end.x} ${end.y}`;
  };

  const elbowPathByX = (start, end, midX) => {
    return `M ${start.x} ${start.y} L ${midX} ${start.y} L ${midX} ${end.y} L ${end.x} ${end.y}`;
  };

  // edges parent -> child
  for(const p of people){
    const from = positions.get(p.id);
    if(!from) continue;
    for(const childId of (p.children||[])){
      const to = positions.get(childId);
      if(!to) continue;
      const line = document.createElementNS("http://www.w3.org/2000/svg","path");
      const sx = from.x + nodeSize.w / 2;
      const sy = from.y + nodeSize.h;
      const tx = to.x + nodeSize.w / 2;
      const ty = to.y;
      const my = (sy + ty) / 2;
      line.setAttribute("d", elbowPath({ x: sx, y: sy }, { x: tx, y: ty }, my));
      line.setAttribute("class","edgeLine");
      viewport.appendChild(line);
    }
  }

  // partner lines
  for(const p of people){
    const from = positions.get(p.id);
    if(!from) continue;
    for(const partnerId of (p.partners||[])){
      if(partnerId <= p.id) continue;
      const to = positions.get(partnerId);
      if(!to) continue;
      const line = document.createElementNS("http://www.w3.org/2000/svg","path");
      const sx = from.x + nodeSize.w / 2;
      const sy = from.y + nodeSize.h / 2;
      const tx = to.x + nodeSize.w / 2;
      const ty = to.y + nodeSize.h / 2;
      if(Math.abs(ty - sy) < 1){
        line.setAttribute("d", `M ${sx} ${sy} L ${tx} ${ty}`);
      }else{
        const mx = (sx + tx) / 2;
        line.setAttribute("d", elbowPathByX({ x: sx, y: sy }, { x: tx, y: ty }, mx));
      }
      line.setAttribute("class","partnerLine");
      viewport.appendChild(line);
    }
  }

  const houseColors = new Map();
  for(const p of people){
    if(!p.house) continue;
    if(!houseColors.has(p.house)){
      houseColors.set(p.house, resolveHouseColor(p.house));
    }
  }

  // nodes
  for(const p of people){
    const pos = positions.get(p.id);
    if(!pos) continue;
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("data-id", p.id);
    g.setAttribute("transform", `translate(${pos.x} ${pos.y})`);

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("width", nodeSize.w);
    rect.setAttribute("height", nodeSize.h);
    rect.setAttribute("rx","10");
    rect.setAttribute("class", `nodeCard ${p.id === selectedId ? "nodeHighlight" : ""}`);
    g.appendChild(rect);

    const houseColor = houseColors.get(p.house);
    if(houseColor){
      const accent = document.createElementNS("http://www.w3.org/2000/svg","rect");
      accent.setAttribute("x","0");
      accent.setAttribute("y","0");
      accent.setAttribute("width", nodeSize.w);
      accent.setAttribute("height","6");
      accent.setAttribute("rx","10");
      accent.setAttribute("fill", houseColor);
      g.appendChild(accent);
    }

    const name = document.createElementNS("http://www.w3.org/2000/svg","text");
    name.setAttribute("x","10");
    name.setAttribute("y","22");
    name.setAttribute("class","nodeLabel");
    name.textContent = safeName(p);
    g.appendChild(name);

    if(p.house){
      const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
      sub.setAttribute("x","10");
      sub.setAttribute("y","40");
      sub.setAttribute("class","nodeSub");
      sub.textContent = p.house;
      g.appendChild(sub);
    }

    if(p.birth || p.death){
      const life = document.createElementNS("http://www.w3.org/2000/svg","text");
      life.setAttribute("x","10");
      life.setAttribute("y","56");
      life.setAttribute("class","nodeSub");
      life.textContent = [p.birth || "", p.death ? `– ${p.death}` : ""].join(" ").trim();
      g.appendChild(life);
    }

    g.addEventListener("click", () => {
      selectedId = p.id;
      render();
    });

    viewport.appendChild(g);
  }

  const legend = el("treeLegend");
  if(legend){
    legend.innerHTML = "";
    const entries = Array.from(houseColors.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
    if(entries.length === 0){
      legend.innerHTML = `<div class="small">No house categories yet.</div>`;
    }else{
      for(const [house, color] of entries){
        const item = document.createElement("button");
        item.type = "button";
        item.className = "legendItem legendButton";
        item.setAttribute("data-house", house);
        item.setAttribute("title", `Edit ${house} color`);
        const swatch = document.createElement("span");
        swatch.className = "legendSwatch";
        swatch.style.background = color;
        item.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = house;
        item.appendChild(text);
        legend.appendChild(item);
      }
    }
  }

  const centeredX = -((minX + maxX) / 2);
  const centeredY = -((minY + maxY) / 2);
  if(treeView.x === 0 && treeView.y === 0){
    treeView.x = centeredX;
    treeView.y = centeredY;
  }
  applyTreeTransform();
}

/** ===========================
 *  Export formats
 *  =========================== */

function exportJSON(){
  return JSON.stringify(store, null, 2);
}

function toYAML(obj, indent=0){
  const sp = "  ".repeat(indent);
  if(obj === null) return "null";
  if(typeof obj === "string"){
    // quote if needed
    if(obj === "" || /[:\n\-\{\}\[\],#&*!|>'"%@`]/.test(obj) || /^\s|\s$/.test(obj)){
      return JSON.stringify(obj); // safe quoting
    }
    return obj;
  }
  if(typeof obj === "number" || typeof obj === "boolean") return String(obj);
  if(Array.isArray(obj)){
    if(obj.length === 0) return "[]";
    return obj.map(v => `${sp}- ${toYAML(v, indent+1).replace(/^  /,"")}`).join("\n");
  }
  // object
  const keys = Object.keys(obj);
  if(keys.length === 0) return "{}";
  return keys.map(k => {
    const v = obj[k];
    if(v && typeof v === "object"){
      return `${sp}${k}:\n${toYAML(v, indent+1)}`;
    }else{
      return `${sp}${k}: ${toYAML(v, indent+1)}`;
    }
  }).join("\n");
}

function exportYAML(){
  return toYAML(store, 0);
}

function exportDOT(){
  // Directed edges: parent -> child
  // Partner edges: undirected-ish (we'll do dir=none)
  const lines = [];
  lines.push('digraph FamilyTree {');
  lines.push('  rankdir=TB;');
  lines.push('  node [shape=box, style="rounded,filled", fillcolor="#111827", color="#334155", fontcolor="#e5e7eb"];');
  lines.push('  edge [color="#64748b"];');

  // nodes
  for(const p of Object.values(store.people)){
    const label = [
      safeName(p),
      p.house ? `\\n${p.house}` : "",
      (p.titles && p.titles.length) ? `\\n(${p.titles.slice(0,3).join(", ")}${p.titles.length>3?"…":""})` : ""
    ].join("");
    lines.push(`  "${p.id}" [label="${escapeDot(label)}"];`);
  }

  // parent-child edges
  for(const p of Object.values(store.people)){
    for(const c of (p.children||[])){
      if(store.people[c]) lines.push(`  "${p.id}" -> "${c}";`);
    }
  }

  // partner edges
  lines.push('  // partners');
  for(const p of Object.values(store.people)){
    for(const partnerId of (p.partners||[])){
      if(partnerId > p.id) { // avoid duplicates with simple ordering
        if(store.people[partnerId]) lines.push(`  "${p.id}" -> "${partnerId}" [dir=none, style=dashed];`);
      }
    }
  }

  lines.push('}');
  return lines.join("\n");
}
function escapeDot(s){
  return (s ?? "").toString().replaceAll("\\","\\\\").replaceAll('"','\\"');
}

function exportMermaid(){
  // Mermaid graph TD
  // parent --> child; partner as --- (undirected) using --- is ok in flowcharts
  const lines = [];
  lines.push("graph TD");
  // nodes
  for(const p of Object.values(store.people)){
    const label = safeName(p) + (p.house ? `\\n${p.house}` : "");
    lines.push(`  ${p.id}["${escapeMermaid(label)}"]`);
  }
  // parent-child edges
  for(const p of Object.values(store.people)){
    for(const c of (p.children||[])){
      if(store.people[c]) lines.push(`  ${p.id} --> ${c}`);
    }
  }
  // partners
  lines.push("  %% partners (dashed)");
  for(const p of Object.values(store.people)){
    for(const partnerId of (p.partners||[])){
      if(partnerId > p.id && store.people[partnerId]){
        lines.push(`  ${p.id} -.-> ${partnerId}`);
      }
    }
  }
  return lines.join("\n");
}
function escapeMermaid(s){
  return (s ?? "").toString().replaceAll('"', '\\"');
}

function exportGEDCOM(){
  // Minimal GEDCOM 5.5-ish: INDI + FAM.
  // We'll generate FAM records for each partner pair and connect children when both parents are in that family.
  // If a child has multiple parents not in a partner pair, they'll still appear via FAM with first two parents found.
  const people = Object.values(store.people);
  const lines = [];
  lines.push("0 HEAD");
  lines.push("1 SOUR WorldbuildingFamilyTreeApp");
  lines.push("1 GEDC");
  lines.push("2 VERS 5.5");
  lines.push("1 CHAR UTF-8");
  lines.push("1 DATE " + new Date().toISOString().slice(0,10));

  // map person id -> GEDCOM @I#
  const indiId = new Map();
  people.forEach((p, idx) => indiId.set(p.id, `@I${idx+1}@`));

  // Build partner families
  const famKeys = new Set();
  const fams = []; // {key, aId, bId, children: []}
  function famKey(a,b){ return [a,b].sort().join("__"); }

  for(const p of people){
    for(const partner of (p.partners||[])){
      if(!store.people[partner]) continue;
      const key = famKey(p.id, partner);
      if(!famKeys.has(key)){
        famKeys.add(key);
        fams.push({ key, aId: p.id, bId: partner, children: [] });
      }
    }
  }

  // Add children to partner fam if child has both parents in that partner pair
  for(const fam of fams){
    const a = personById(fam.aId);
    const b = personById(fam.bId);
    if(!a || !b) continue;
    // children that appear in either parent's children list
    const cand = new Set([...(a.children||[]), ...(b.children||[])]);
    for(const cId of cand){
      const c = personById(cId);
      if(!c) continue;
      const hasA = (c.parents||[]).includes(a.id);
      const hasB = (c.parents||[]).includes(b.id);
      if(hasA && hasB) fam.children.push(cId);
    }
  }

  // For children with parents but no partner family, create a synthetic family with first 2 parents (or 1)
  const usedChild = new Set(fams.flatMap(f => f.children));
  for(const c of people){
    if((c.parents||[]).length === 0) continue;
    if(usedChild.has(c.id)) continue;
    const p1 = c.parents[0];
    const p2 = c.parents[1] || null;
    const key = famKey(p1, p2 || ("single__" + p1 + "__" + c.id));
    fams.push({ key, aId: p1, bId: p2, children: [c.id], synthetic: true });
  }

  // write INDI
  people.forEach(p => {
    lines.push(`0 ${indiId.get(p.id)} INDI`);
    lines.push(`1 NAME ${p.name || "?"}`);
    if(p.sex) lines.push(`1 SEX ${p.sex === "X" ? "U" : p.sex}`); // U for unknown/other-ish
    if(p.birth) {
      lines.push("1 BIRT");
      lines.push(`2 DATE ${p.birth}`);
    }
    if(p.death) {
      lines.push("1 DEAT");
      lines.push(`2 DATE ${p.death}`);
    }
    if(p.house) lines.push(`1 NOTE House/Clan: ${p.house}`);
    if(p.titles && p.titles.length) lines.push(`1 NOTE Titles: ${p.titles.join(", ")}`);
    if(p.notes) lines.push(`1 NOTE ${p.notes.replaceAll("\n"," ")}`);
  });

  // assign @F#
  const famId = new Map();
  fams.forEach((f, idx) => famId.set(f.key, `@F${idx+1}@`));

  // connect INDI to FAMS/FAMC
  // - spouses: FAMS
  // - children: FAMC for first matching family they appear in
  // We'll do a second pass and append these links by re-writing: easiest is to add them as NOTE-like blocks? We'll do it properly by emitting extra lines right after INDI, so we need indices—keeping it simple: emit extra "1 FAMS/FAMC" immediately after creation by re-looping with computed matches.
  // We'll implement by building lookup maps and re-export in one pass with those lines included (so redo the INDI emission).
  lines.splice( lines.findIndex(x => x.startsWith("0 @I1@ INDI")), lines.length ); // remove INDI blocks we wrote
  // Re-add HEAD and then INDI with links.
  const head = [];
  head.push("0 HEAD");
  head.push("1 SOUR WorldbuildingFamilyTreeApp");
  head.push("1 GEDC");
  head.push("2 VERS 5.5");
  head.push("1 CHAR UTF-8");
  head.push("1 DATE " + new Date().toISOString().slice(0,10));
  lines.length = 0;
  lines.push(...head);

  // Build lookups
  const spouseFams = new Map(); // personId -> Set(famKey)
  const childFam = new Map();   // childId -> famKey
  for(const f of fams){
    if(f.aId && store.people[f.aId]){
      if(!spouseFams.has(f.aId)) spouseFams.set(f.aId, new Set());
      spouseFams.get(f.aId).add(f.key);
    }
    if(f.bId && store.people[f.bId]){
      if(!spouseFams.has(f.bId)) spouseFams.set(f.bId, new Set());
      spouseFams.get(f.bId).add(f.key);
    }
    for(const c of (f.children||[])){
      if(!childFam.has(c)) childFam.set(c, f.key);
    }
  }

  // emit INDI with links
  people.forEach(p => {
    lines.push(`0 ${indiId.get(p.id)} INDI`);
    lines.push(`1 NAME ${p.name || "?"}`);
    if(p.sex) lines.push(`1 SEX ${p.sex === "X" ? "U" : p.sex}`);
    // family links
    const famc = childFam.get(p.id);
    if(famc) lines.push(`1 FAMC ${famId.get(famc)}`);
    const famsSet = spouseFams.get(p.id);
    if(famsSet){
      for(const fk of famsSet){
        lines.push(`1 FAMS ${famId.get(fk)}`);
      }
    }
    if(p.birth) { lines.push("1 BIRT"); lines.push(`2 DATE ${p.birth}`); }
    if(p.death) { lines.push("1 DEAT"); lines.push(`2 DATE ${p.death}`); }
    if(p.house) lines.push(`1 NOTE House/Clan: ${p.house}`);
    if(p.titles && p.titles.length) lines.push(`1 NOTE Titles: ${p.titles.join(", ")}`);
    if(p.notes) lines.push(`1 NOTE ${p.notes.replaceAll("\n"," ")}`);
  });

  // emit FAM
  fams.forEach(f => {
    lines.push(`0 ${famId.get(f.key)} FAM`);
    if(f.aId && store.people[f.aId]) lines.push(`1 HUSB ${indiId.get(f.aId)}`);
    if(f.bId && store.people[f.bId]) lines.push(`1 WIFE ${indiId.get(f.bId)}`);
    for(const cId of (f.children||[])){
      if(store.people[cId]) lines.push(`1 CHIL ${indiId.get(cId)}`);
    }
    if(f.synthetic) lines.push(`1 NOTE Synthetic family (no explicit partnership)`);
  });

  lines.push("0 TRLR");
  return lines.join("\n");
}

function generateExport(){
  const fmt = el("exportFormat").value;
  let txt = "";
  if(fmt === "json") txt = exportJSON();
  else if(fmt === "yaml") txt = exportYAML();
  else if(fmt === "dot") txt = exportDOT();
  else if(fmt === "mermaid") txt = exportMermaid();
  else if(fmt === "gedcom") txt = exportGEDCOM();
  el("out").value = txt;
}

/** ===========================
 *  Import
 *  =========================== */
function importJSON({ merge }){
  const raw = el("importBox").value.trim();
  if(!raw) return alert("Paste JSON first.");
  let parsed;
  try{ parsed = JSON.parse(raw); }
  catch{ return alert("Invalid JSON."); }

  if(!parsed || typeof parsed !== "object" || !parsed.people){
    return alert("JSON doesn't look like an export from this app (missing people).");
  }

  if(!merge){
    store = normalizeStore(parsed);
    selectedId = null;
    saveStore();
    return;
  }

  // merge: keep existing, add new ids; if conflict, rename incoming id
  const incomingPeople = parsed.people || {};
  for(const [id, p] of Object.entries(incomingPeople)){
    let newId = id;
    while(store.people[newId]) newId = uid();

    // clone and rewrite internal links if id changed
    const cloned = JSON.parse(JSON.stringify(p));
    cloned.id = newId;

    // remap references when id changes: we only remap self-id; other ids are left as-is (best-effort)
    if(newId !== id){
      // if any other incoming person refers to old id, that won't be fixed here (complex).
      // We'll at least keep this person consistent internally.
    }

    store.people[newId] = cloned;
  }
  saveStore();
  alert("Merged. Note: references between imported records aren’t fully remapped when IDs collide. Use non-merge import for perfect fidelity.");
}

/** ===========================
 *  Wire UI
 *  =========================== */
el("btnAdd").onclick = () => {
  const name = el("pName").value.trim();
  if(!name) return alert("Name is required.");
  addPerson({
    name,
    sex: el("pSex").value,
    birth: el("pBirth").value,
    death: el("pDeath").value,
    house: el("pHouse").value,
    titles: normalizeTitles(el("pTitles").value),
    notes: el("pNotes").value
  });
  clearCreateForm();
  saveStore();
};

el("btnAddAndSelect").onclick = () => {
  const name = el("pName").value.trim();
  if(!name) return alert("Name is required.");
  const id = addPerson({
    name,
    sex: el("pSex").value,
    birth: el("pBirth").value,
    death: el("pDeath").value,
    house: el("pHouse").value,
    titles: normalizeTitles(el("pTitles").value),
    notes: el("pNotes").value
  });
  clearCreateForm();
  selectedId = id;
  saveStore();
};

function clearCreateForm(){
  el("pName").value = "";
  el("pSex").value = "";
  el("pBirth").value = "";
  el("pDeath").value = "";
  el("pHouse").value = "";
  el("pTitles").value = "";
  el("pNotes").value = "";
}

el("q").addEventListener("input", () => renderPeopleList());
el("btnSortName").onclick = () => { sortMode = "name"; renderPeopleList(); };
el("btnSortHouse").onclick = () => { sortMode = "house"; renderPeopleList(); };

el("btnExport").onclick = generateExport;

el("btnCopy").onclick = async () => {
  const txt = el("out").value;
  if(!txt) return;
  try{
    await navigator.clipboard.writeText(txt);
    alert("Copied!");
  }catch{
    alert("Copy failed (browser restriction). Select and copy manually.");
  }
};

el("btnDownload").onclick = () => {
  const txt = el("out").value;
  if(!txt) return alert("Generate export first.");
  const fmt = el("exportFormat").value;
  const ext = fmt === "json" ? "json"
            : fmt === "yaml" ? "yml"
            : fmt === "dot" ? "dot"
            : fmt === "mermaid" ? "mmd"
            : "ged";
  const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `family_tree_export.${ext}`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
};

el("btnImport").onclick = () => importJSON({ merge:false });
el("btnMergeImport").onclick = () => importJSON({ merge:true });

el("btnSave").onclick = () => saveStore();

el("btnReset").onclick = () => {
  if(!confirm("Reset will erase the saved tree in this browser. Continue?")) return;
  store = freshStore();
  selectedId = null;
  saveStore();
};

el("btnApplyPreset").onclick = () => {
  const presetIndex = Number(el("themePreset").value);
  const preset = themePresets[presetIndex];
  if(!preset) return;
  currentTheme = JSON.parse(JSON.stringify(preset));
  applyTheme(currentTheme);
  saveTheme();
  renderThemeControls();
};

el("btnResetTheme").onclick = () => {
  currentTheme = defaultTheme();
  applyTheme(currentTheme);
  saveTheme();
  renderThemeControls();
};

/** ===========================
 *  Tree interactions
 *  =========================== */
const treeSvg = el("treeSvg");
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let pinchStartDistance = null;
let pinchStartScale = 1;

el("btnZoomIn").onclick = () => {
  const rect = treeSvg.getBoundingClientRect();
  zoomTreeAt(getSvgPoint(rect.left + rect.width / 2, rect.top + rect.height / 2), treeView.scale + 0.15);
};
el("btnZoomOut").onclick = () => {
  const rect = treeSvg.getBoundingClientRect();
  zoomTreeAt(getSvgPoint(rect.left + rect.width / 2, rect.top + rect.height / 2), treeView.scale - 0.15);
};
el("btnZoomReset").onclick = () => resetTreeView();

treeSvg.addEventListener("wheel", (event) => {
  event.preventDefault();
  const direction = Math.sign(event.deltaY);
  const next = treeView.scale + (direction > 0 ? -0.1 : 0.1);
  const point = getSvgPoint(event.clientX, event.clientY);
  zoomTreeAt(point, next);
}, { passive: false });

treeSvg.addEventListener("mousedown", (event) => {
  isDragging = true;
  dragStart = { x: event.clientX - treeView.x, y: event.clientY - treeView.y };
  treeSvg.classList.add("dragging");
});
window.addEventListener("mousemove", (event) => {
  if(!isDragging) return;
  treeView.x = event.clientX - dragStart.x;
  treeView.y = event.clientY - dragStart.y;
  applyTreeTransform();
});
window.addEventListener("mouseup", () => {
  isDragging = false;
  treeSvg.classList.remove("dragging");
});

treeSvg.addEventListener("touchstart", (event) => {
  if(event.touches.length === 1){
    const touch = event.touches[0];
    isDragging = true;
    dragStart = { x: touch.clientX - treeView.x, y: touch.clientY - treeView.y };
    treeSvg.classList.add("dragging");
  }else if(event.touches.length === 2){
    isDragging = false;
    treeSvg.classList.remove("dragging");
    pinchStartDistance = getTouchDistance(event.touches[0], event.touches[1]);
    pinchStartScale = treeView.scale;
  }
}, { passive: false });

treeSvg.addEventListener("touchmove", (event) => {
  if(event.touches.length === 1 && isDragging){
    const touch = event.touches[0];
    treeView.x = touch.clientX - dragStart.x;
    treeView.y = touch.clientY - dragStart.y;
    applyTreeTransform();
    event.preventDefault();
  }else if(event.touches.length === 2){
    const t1 = event.touches[0];
    const t2 = event.touches[1];
    const nextDistance = getTouchDistance(t1, t2);
    if(pinchStartDistance){
      const nextScale = pinchStartScale * (nextDistance / pinchStartDistance);
      const midpoint = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
      zoomTreeAt(getSvgPoint(midpoint.x, midpoint.y), nextScale);
    }
    event.preventDefault();
  }
}, { passive: false });

treeSvg.addEventListener("touchend", (event) => {
  if(event.touches.length === 0){
    isDragging = false;
    treeSvg.classList.remove("dragging");
    pinchStartDistance = null;
  }else if(event.touches.length === 1){
    const touch = event.touches[0];
    isDragging = true;
    dragStart = { x: touch.clientX - treeView.x, y: touch.clientY - treeView.y };
  }
});

treeSvg.addEventListener("touchcancel", () => {
  isDragging = false;
  treeSvg.classList.remove("dragging");
  pinchStartDistance = null;
});

function autosave(){
  // lightweight: saving on most mutations is already handled via saveStore()
  el("status").textContent = "Autosave: on • Last updated: " + (store.meta.updatedAt ? store.meta.updatedAt.slice(0,19).replace("T"," ") : "—");
}
setInterval(autosave, 1200);

function colorToHex(value){
  if(!value) return "#000000";
  if(value.startsWith("#")) return value;
  const rgba = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
  if(!rgba) return "#000000";
  const r = Number(rgba[1]).toString(16).padStart(2, "0");
  const g = Number(rgba[2]).toString(16).padStart(2, "0");
  const b = Number(rgba[3]).toString(16).padStart(2, "0");
  return `#${r}${g}${b}`;
}

function hexToRgba(hex, alpha){
  const raw = hex.replace("#", "");
  if(raw.length !== 6) return hex;
  const r = parseInt(raw.slice(0,2), 16);
  const g = parseInt(raw.slice(2,4), 16);
  const b = parseInt(raw.slice(4,6), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function normalizeHex(value){
  if(!value) return null;
  const trimmed = value.trim();
  const hex = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
  if(!/^#([0-9a-f]{6})$/i.test(hex)) return null;
  return hex.toUpperCase();
}

function hexToRgb(hex){
  const raw = hex.replace("#", "");
  return {
    r: parseInt(raw.slice(0,2), 16),
    g: parseInt(raw.slice(2,4), 16),
    b: parseInt(raw.slice(4,6), 16)
  };
}

function rgbToHex({ r, g, b }){
  const toHex = (val) => Math.max(0, Math.min(255, val)).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
}

function getSvgPoint(clientX, clientY){
  const pt = treeSvg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const matrix = treeSvg.getScreenCTM();
  if(!matrix) return { x: clientX, y: clientY };
  const result = pt.matrixTransform(matrix.inverse());
  return { x: result.x, y: result.y };
}

function zoomTreeAt(point, nextScale){
  const clamped = clampTreeScale(nextScale);
  const prevScale = treeView.scale;
  const prevX = treeView.x;
  const prevY = treeView.y;
  const screenX = point.x * prevScale + prevX;
  const screenY = point.y * prevScale + prevY;
  treeView.scale = clamped;
  treeView.x = screenX - point.x * clamped;
  treeView.y = screenY - point.y * clamped;
  applyTreeTransform();
}

function getTouchDistance(t1, t2){
  const dx = t1.clientX - t2.clientX;
  const dy = t1.clientY - t2.clientY;
  return Math.hypot(dx, dy);
}

function renderThemeControls(){
  const presetSelect = el("themePreset");
  presetSelect.innerHTML = "";
  themePresets.forEach((preset, idx) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = preset.name;
    presetSelect.appendChild(opt);
  });
  const matchIndex = themePresets.findIndex(preset => preset.name === currentTheme.name);
  presetSelect.value = matchIndex >= 0 ? String(matchIndex) : "0";

  const themeFields = [
    { label: "Background", key: "--bg" },
    { label: "Panel", key: "--panel" },
    { label: "Panel Alt", key: "--panel2" },
    { label: "Text", key: "--text" },
    { label: "Muted", key: "--muted" },
    { label: "Accent", key: "--accent" },
    { label: "Danger", key: "--danger" },
    { label: "Success", key: "--ok" },
    { label: "Border", key: "--border" },
    { label: "Tree BG", key: "--tree-bg" },
    { label: "Tree Glow", key: "--tree-glow", glow: true },
    { label: "Node BG", key: "--node-bg" },
    { label: "Node Stroke", key: "--node-stroke" },
    { label: "Node Highlight", key: "--node-highlight" },
    { label: "Node Text", key: "--node-text" },
    { label: "Node Subtext", key: "--node-sub" },
    { label: "Edge", key: "--edge" },
    { label: "Partner", key: "--partner" }
  ];

  const grid = el("themeGrid");
  grid.innerHTML = "";
  themeFields.forEach(field => {
    const wrapper = document.createElement("div");
    wrapper.className = "themeField";
    const label = document.createElement("span");
    label.textContent = field.label;
    const input = document.createElement("input");
    input.type = "color";
    const rawValue = currentTheme.values[field.key] || "";
    input.value = colorToHex(rawValue);
    input.addEventListener("input", (event) => {
      const value = event.target.value;
      currentTheme.name = "Custom";
      currentTheme.values[field.key] = field.glow ? hexToRgba(value, 0.12) : value;
      applyTheme(currentTheme);
      saveTheme();
    });
    wrapper.appendChild(label);
    wrapper.appendChild(input);
    grid.appendChild(wrapper);
  });
}

applyTheme(currentTheme);
renderThemeControls();
render();

const houseColorModal = el("houseColorModal");
const houseColorTitle = el("houseColorTitle");
const houseColorPreview = el("houseColorPreview");
const houseColorHex = el("houseColorHex");
const houseColorPicker = el("houseColorPicker");
const houseColorR = el("houseColorR");
const houseColorG = el("houseColorG");
const houseColorB = el("houseColorB");
const houseColorRValue = el("houseColorRValue");
const houseColorGValue = el("houseColorGValue");
const houseColorBValue = el("houseColorBValue");
const houseColorClose = el("houseColorClose");
const houseColorReset = el("houseColorReset");
let activeHouse = null;
let updatingHouseControls = false;

function openHouseColorModal(house){
  activeHouse = house;
  houseColorTitle.textContent = `Edit ${house} color`;
  const base = resolveHouseColor(house) || "#FFFFFF";
  updateHouseControls(base);
  houseColorModal.classList.add("is-open");
  houseColorModal.setAttribute("aria-hidden", "false");
}

function closeHouseColorModal(){
  activeHouse = null;
  houseColorModal.classList.remove("is-open");
  houseColorModal.setAttribute("aria-hidden", "true");
}

function updateHouseControls(color){
  const hex = normalizeHex(color) || "#FFFFFF";
  const rgb = hexToRgb(hex);
  updatingHouseControls = true;
  houseColorPreview.style.background = hex;
  houseColorHex.value = hex;
  houseColorPicker.value = hex;
  houseColorR.value = String(rgb.r);
  houseColorG.value = String(rgb.g);
  houseColorB.value = String(rgb.b);
  houseColorRValue.textContent = String(rgb.r);
  houseColorGValue.textContent = String(rgb.g);
  houseColorBValue.textContent = String(rgb.b);
  updatingHouseControls = false;
}

function applyHouseColor(hex){
  if(!activeHouse) return;
  const normalized = normalizeHex(hex);
  if(!normalized) return;
  houseColorOverrides[activeHouse] = normalized;
  saveHouseColorOverrides();
  updateHouseControls(normalized);
  renderTree();
}

function resetHouseColor(){
  if(!activeHouse) return;
  delete houseColorOverrides[activeHouse];
  saveHouseColorOverrides();
  const fallback = resolveHouseColor(activeHouse) || "#FFFFFF";
  updateHouseControls(fallback);
  renderTree();
}

houseColorHex.addEventListener("input", (event) => {
  if(updatingHouseControls) return;
  const normalized = normalizeHex(event.target.value);
  if(!normalized) return;
  applyHouseColor(normalized);
});

houseColorPicker.addEventListener("input", (event) => {
  if(updatingHouseControls) return;
  applyHouseColor(event.target.value);
});

[houseColorR, houseColorG, houseColorB].forEach(input => {
  input.addEventListener("input", () => {
    if(updatingHouseControls) return;
    const rgb = {
      r: Number(houseColorR.value),
      g: Number(houseColorG.value),
      b: Number(houseColorB.value)
    };
    const hex = rgbToHex(rgb);
    applyHouseColor(hex);
  });
});

houseColorClose.onclick = () => closeHouseColorModal();
houseColorReset.onclick = () => resetHouseColor();
houseColorModal.addEventListener("click", (event) => {
  if(event.target.matches('[data-action="close-house-color"]')) closeHouseColorModal();
});

document.addEventListener("click", (event) => {
  const target = event.target.closest(".legendButton");
  if(!target) return;
  const house = target.getAttribute("data-house");
  if(house) openHouseColorModal(house);
});
</script>
</body>
</html>
