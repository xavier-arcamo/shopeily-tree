<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Worldbuilding Family Tree Builder (Offline)</title>
  <style>
    :root {
      --bg:#0b0f14;
      --panel:#121923;
      --panel2:#0f151e;
      --text:#e7eef8;
      --muted:#9bb0c7;
      --accent:#6ee7ff;
      --danger:#ff6e8a;
      --ok:#7CFFA6;
      --border:#223145;
      --tree-bg:#0c131c;
      --tree-glow:rgba(110,231,255,.08);
      --node-bg:#111827;
      --node-stroke:#334155;
      --node-highlight:#6ee7ff;
      --node-text:#e7eef8;
      --node-sub:#9bb0c7;
      --edge:#475569;
      --partner:#7c7c7c;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--text);}
    a{color:var(--accent)}
    header{padding:14px 16px;border-bottom:1px solid var(--border);display:flex;gap:12px;align-items:center;justify-content:space-between;background:linear-gradient(180deg,#0f1621,#0b0f14);}
    header h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.2px}
    header .right{display:flex;gap:10px;align-items:center}
    .pill{padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:rgba(255,255,255,.03);color:var(--muted);font-size:12px}
    main{display:grid;grid-template-columns: 420px 1fr;min-height:calc(100vh - 56px);}
    @media (max-width: 980px){ main{grid-template-columns: 1fr; } }
    .col{padding:14px 14px 18px; border-right:1px solid var(--border);}
    .col:last-child{border-right:none}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:0;margin-bottom:12px; box-shadow: 0 12px 40px rgba(0,0,0,.25);}
    .panelSummary{
      margin:0;
      padding:12px;
      font-size:13px;
      color:var(--muted);
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.12em;
      cursor:pointer;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .panelSummary::-webkit-details-marker{display:none}
    .panelSummary::after{
      content:"‚ñæ";
      font-size:12px;
      color:var(--muted);
    }
    details:not([open]) > .panelSummary::after{content:"‚ñ∏";}
    .panelBody{padding:0 12px 12px}
    .sectionTitle{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:700;text-transform:uppercase;letter-spacing:.12em}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row > *{flex:1}
    label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
    input, select, textarea{
      width:100%; padding:10px 10px; border-radius:10px;
      border:1px solid var(--border); background:var(--panel2); color:var(--text);
      outline:none;
    }
    input[type="color"]{
      padding:0;
      height:38px;
      border-radius:10px;
      overflow:hidden;
    }
    textarea{min-height:80px; resize:vertical}
    button{
      padding:10px 12px;border-radius:10px;border:1px solid var(--border);
      background:rgba(255,255,255,.04);color:var(--text);cursor:pointer;
    }
    button:hover{border-color:#2e4564}
    button.primary{background:linear-gradient(180deg, rgba(110,231,255,.18), rgba(110,231,255,.06)); border-color: rgba(110,231,255,.35);}
    button.danger{background:linear-gradient(180deg, rgba(255,110,138,.20), rgba(255,110,138,.06)); border-color: rgba(255,110,138,.35);}
    button.ok{background:linear-gradient(180deg, rgba(124,255,166,.20), rgba(124,255,166,.06)); border-color: rgba(124,255,166,.35);}
    .small{font-size:12px;color:var(--muted)}
    .list{max-height:48vh; overflow:auto; padding-right:6px}
    .card{
      border:1px solid var(--border); background:rgba(255,255,255,.02);
      border-radius:12px; padding:10px; margin-bottom:10px;
    }
    .cardTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .name{font-weight:800}
    .tags{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
    .tag{font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:var(--muted);background:rgba(255,255,255,.03)}
    .kvs{display:grid;grid-template-columns: 120px 1fr; gap:6px 10px; margin-top:10px}
    .kvk{color:var(--muted);font-size:12px}
    .kvv{font-size:12px}
    .split{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
    @media (max-width: 980px){ .split{grid-template-columns: 1fr;} }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    .toolbar .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .status{font-size:12px;color:var(--muted)}
    .hr{height:1px;background:var(--border);margin:10px 0}
    .twoCol{display:grid;grid-template-columns: 1fr 1fr; gap:10px}
    @media (max-width: 980px){ .twoCol{grid-template-columns: 1fr;} }
    .hint{font-size:12px;color:var(--muted);line-height:1.35}
    .warn{color:#ffd58a}
    .treeWrap{
      position:relative;
      height:420px;
      border-radius:12px;
      background:radial-gradient(circle at 20% 20%, var(--tree-glow), transparent 45%), var(--tree-bg);
      border:1px solid var(--border);
      overflow:hidden;
    }
    .treeWrap.expanded{
      height:70vh;
      min-height:520px;
    }
    .treeCanvas{
      width:100%;
      height:100%;
      cursor:grab;
      touch-action:none;
    }
    .treeCanvas.dragging{cursor:grabbing}
    .treeControls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .treeHint{font-size:12px;color:var(--muted);margin-top:8px}
    .treeLegend{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .legendItem{display:flex;align-items:center;gap:6px;font-size:12px;color:var(--muted)}
    .legendButton{
      background:none;
      border:1px solid transparent;
      padding:4px 6px;
      border-radius:8px;
      cursor:pointer;
    }
    .legendButton:hover{
      border-color:var(--border);
      color:var(--text);
    }
    .legendSwatch{width:12px;height:12px;border-radius:4px;border:1px solid rgba(255,255,255,.2)}
    .legendStack{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-top:8px;
    }
    .tokenRow{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:6px;
    }
    .token{
      width:18px;
      height:18px;
      border-radius:6px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      cursor:pointer;
    }
    .token.active{
      background:var(--accent);
      border-color:rgba(110,231,255,.5);
      box-shadow:0 0 6px rgba(110,231,255,.45);
    }
    .tokenMeta{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }
    .inlineToggle{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:var(--muted);
    }
    .nodeCard{
      fill:var(--node-bg);
      stroke:var(--node-stroke);
      stroke-width:1;
    }
    .nodeHighlight{
      stroke:var(--node-highlight);
      stroke-width:1.5;
    }
    .edgeLine{
      stroke:var(--edge);
      stroke-width:1.2;
      fill:none;
      stroke-linejoin:miter;
      stroke-linecap:square;
    }
    .partnerLine{
      stroke:var(--partner);
      stroke-width:1;
      stroke-dasharray:5 4;
      opacity:.7;
      fill:none;
      stroke-linejoin:miter;
      stroke-linecap:square;
    }
    .nodeLabel{
      font-size:11px;
      fill:var(--node-text);
      pointer-events:none;
    }
    .nodeSub{
      font-size:10px;
      fill:var(--node-sub);
      pointer-events:none;
    }
    .themeGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 980px){ .themeGrid{grid-template-columns: 1fr;} }
    .themeField{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.02);
    }
    .themeField span{
      font-size:12px;
      color:var(--muted);
      min-width:92px;
    }
    .modal{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .modal.is-open{display:flex}
    .modalBackdrop{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,.5);
    }
    .modalPanel{
      position:relative;
      z-index:1;
      width:min(420px, 92vw);
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:16px;
      box-shadow:0 20px 50px rgba(0,0,0,.35);
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-bottom:12px;
    }
    .modalTitle{
      font-size:14px;
      font-weight:700;
      margin:0;
    }
    .colorPreview{
      width:100%;
      height:36px;
      border-radius:10px;
      border:1px solid var(--border);
      margin-bottom:12px;
    }
    .sliderRow{
      display:grid;
      grid-template-columns: 60px 1fr 60px;
      gap:8px;
      align-items:center;
      margin-bottom:8px;
      font-size:12px;
      color:var(--muted);
    }
    .sliderRow input[type="range"]{
      width:100%;
    }
    .viewTabs{
      display:flex;
      gap:8px;
      margin-bottom:12px;
    }
    .viewTabs button{
      border-radius:999px;
      padding:8px 14px;
      font-size:12px;
    }
    .viewTabs button.active{
      background:linear-gradient(180deg, rgba(110,231,255,.24), rgba(110,231,255,.08));
      border-color:rgba(110,231,255,.35);
      color:var(--text);
    }
    .viewPanel{
      display:none;
    }
    .viewPanel.active{
      display:block;
    }
    .timelineControls{
      display:grid;
      grid-template-columns: repeat(5, minmax(0, 1fr)) auto;
      gap:10px;
      align-items:end;
      margin-bottom:12px;
    }
    @media (max-width: 980px){
      .timelineControls{
        grid-template-columns: 1fr 1fr;
      }
    }
    .timelineWrap{
      border:1px solid var(--border);
      border-radius:12px;
      background:radial-gradient(circle at 20% 20%, rgba(110,231,255,.08), transparent 45%), var(--tree-bg);
      overflow:hidden;
    }
    .timelineScroller{
      overflow:auto;
      padding:14px;
    }
    .timelineInner{
      position:relative;
      min-height:220px;
      padding:10px 30px 20px;
    }
    .timelineAxis{
      position:absolute;
      top:34px;
      left:0;
      right:0;
      height:2px;
      background:rgba(110,231,255,.2);
    }
    .timelineTick{
      position:absolute;
      top:24px;
      width:1px;
      height:20px;
      background:rgba(110,231,255,.35);
    }
    .timelineTickLabel{
      position:absolute;
      top:46px;
      transform:translateX(-50%);
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
    }
    .timelineEntries{
      position:absolute;
      inset:0;
      pointer-events:none;
    }
    .timelineEntry{
      position:absolute;
      display:flex;
      gap:8px;
      align-items:flex-start;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.1);
      background:rgba(15,21,30,.9);
      color:var(--text);
      box-shadow:0 10px 20px rgba(0,0,0,.25);
      transform:translate(-50%, 0);
      transition:transform .2s ease, box-shadow .2s ease, border-color .2s ease;
      pointer-events:auto;
      cursor:pointer;
      min-width:180px;
      max-width:240px;
    }
    .timelineEntry:hover{
      transform:translate(-50%, -4px) scale(1.02);
      box-shadow:0 16px 30px rgba(110,231,255,.25);
      border-color:rgba(110,231,255,.45);
    }
    .timelineEntry.is-selected{
      border-color:rgba(110,231,255,.6);
      box-shadow:0 18px 34px rgba(110,231,255,.3);
    }
    .timelineDot{
      width:10px;
      height:10px;
      border-radius:999px;
      background:var(--accent);
      box-shadow:0 0 8px rgba(110,231,255,.6);
      margin-top:6px;
      flex-shrink:0;
    }
    .timelineContent{
      display:flex;
      flex-direction:column;
      gap:4px;
      text-align:left;
    }
    .timelineName{
      font-weight:700;
      font-size:13px;
    }
    .timelineMeta{
      font-size:11px;
      color:var(--muted);
    }
  </style>
</head>
<body>
<header>
  <h1>Worldbuilding Family Tree Builder</h1>
  <div class="right">
    <div class="pill" id="countPill">0 people</div>
    <button class="ok" id="btnSave">Save</button>
    <button class="danger" id="btnReset">Reset</button>
  </div>
</header>

<main>
  <!-- LEFT: Create/Search/List -->
  <section class="col">
    <details class="panel" open>
      <summary class="panelSummary">Create Person</summary>
      <div class="panelBody">
      <div class="row">
        <div>
          <label>Name *</label>
          <input id="pName" placeholder="e.g., Aurelian Voss" />
        </div>
        <div>
          <label>Sex/Gender</label>
          <select id="pSex">
            <option value="">(unspecified)</option>
            <option value="M">Male ‚ôÇÔ∏è</option>
            <option value="F">Female ‚ôÄÔ∏è</option>
            <option value="X">X / other</option>
          </select>
        </div>
      </div>
      <label class="inlineToggle" style="margin-top:2px">
        <input id="pRuler" type="checkbox" />
        Crown title (ruler/emperor) üëë
      </label>
      <div class="twoCol">
        <div>
          <label>Birth Year</label>
          <input id="pBirth" type="number" step="1" placeholder="e.g., 982" />
        </div>
        <div>
          <label>Death Year</label>
          <input id="pDeath" type="number" step="1" placeholder="optional" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Age at Death</label>
          <input id="pAgeAtDeath" type="number" step="1" placeholder="auto-calculates from years" />
        </div>
        <div style="align-self:end">
          <label class="inlineToggle">
            <input id="pAlive" type="checkbox" />
            Currently alive
          </label>
        </div>
      </div>
      <div class="row">
        <div>
          <label>House/Clan</label>
          <input id="pHouse" placeholder="e.g., House Voss" />
        </div>
        <div>
          <label>Titles (comma-separated)</label>
          <input id="pTitles" placeholder="e.g., Archon, Sword-Saint" />
        </div>
      </div>
      <label>Notes</label>
      <textarea id="pNotes" placeholder="Lore notes, personality, plot hooks‚Ä¶"></textarea>
      <div class="row">
        <button class="primary" id="btnAdd">Add Person</button>
        <button id="btnAddAndSelect">Add + Select</button>
      </div>
      <div class="hint">
        Tip: Enter any two values (birth year, death year, age at death) and the third is auto-calculated.
      </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Search & People</summary>
      <div class="panelBody">
      <label>Search</label>
      <input id="q" placeholder="name, house, title‚Ä¶" />
      <div class="toolbar" style="margin-top:10px">
        <div class="left">
          <button id="btnSortName">Sort: Name</button>
          <button id="btnSortHouse">Sort: House</button>
        </div>
        <div class="status" id="status">Autosave: on</div>
      </div>
      <div class="hr"></div>
      <div class="list" id="peopleList"></div>
      <div class="hint">
        Click a person to edit & link relationships.
      </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Bloodlines</summary>
      <div class="panelBody">
      <div class="row">
        <div>
          <label>Name *</label>
          <input id="bloodlineName" placeholder="e.g., Drake" />
        </div>
        <div>
          <label>Token Slots</label>
          <input id="bloodlineSlots" type="number" min="1" max="50" placeholder="12" />
        </div>
      </div>
      <label>Short Description</label>
      <input id="bloodlineDesc" placeholder="e.g., Ancient draconic lineage" />
      <label>Notes</label>
      <textarea id="bloodlineNotes" placeholder="Lore notes, source, quirks‚Ä¶"></textarea>
      <div class="row">
        <button class="primary" id="btnBloodlineSave">Add Bloodline</button>
        <button id="btnBloodlineReset">Clear</button>
      </div>
      <div class="hr"></div>
      <div class="list" id="bloodlineList"></div>
      </div>
    </details>
  </section>

  <!-- RIGHT: Detail / Relationships / Export -->
  <section class="col">
    <details class="panel" id="detailPanel" open>
      <summary class="panelSummary">Selected Person</summary>
      <div class="panelBody" id="detailBody">
        <div class="small">No person selected.</div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Visual Views</summary>
      <div class="panelBody">
        <div class="viewTabs">
          <button type="button" class="active" data-view-tab="tree">Tree</button>
          <button type="button" data-view-tab="timeline">Timeline</button>
        </div>

        <div class="viewPanel active" data-view-panel="tree">
          <div class="toolbar" style="margin-bottom:8px">
            <div class="left treeControls">
              <button id="btnZoomIn">Zoom +</button>
              <button id="btnZoomOut">Zoom ‚àí</button>
              <button id="btnZoomReset">Reset View</button>
            </div>
            <div class="row" style="gap:12px;align-items:center">
              <label class="inlineToggle">
                <input type="checkbox" id="expandedToggle" />
                Expanded View
              </label>
              <div class="status" id="treeStatus">Zoom 100%</div>
            </div>
          </div>
          <div class="treeWrap" id="treeWrap">
            <svg id="treeSvg" class="treeCanvas" viewBox="0 0 1200 700" preserveAspectRatio="xMidYMid meet">
              <g id="treeViewport">
                <rect x="-6000" y="-6000" width="12000" height="12000" fill="transparent"></rect>
              </g>
            </svg>
          </div>
          <div class="treeHint">
            Drag to pan. Scroll or pinch to zoom. Click a card to select.
          </div>
          <div class="sectionTitle" style="margin-top:12px">Houses</div>
          <div class="treeLegend" id="treeLegend"></div>
          <div class="sectionTitle" style="margin-top:12px">Bloodlines</div>
          <div class="treeLegend legendStack" id="bloodlineLegend"></div>
        </div>

        <div class="viewPanel" data-view-panel="timeline">
          <div class="toolbar" style="margin-bottom:8px">
            <div class="left treeControls">
              <button id="btnTimelineAuto">Auto-fit</button>
            </div>
            <div class="status" id="timelineStatus">Zoom 100%</div>
          </div>
          <div class="timelineControls">
            <div>
              <label>Start</label>
              <input id="timelineStart" type="number" step="any" />
            </div>
            <div>
              <label>End</label>
              <input id="timelineEnd" type="number" step="any" />
            </div>
            <div>
              <label>Step</label>
              <input id="timelineStep" type="number" step="any" />
            </div>
            <div>
              <label>Unit Label</label>
              <input id="timelineUnit" placeholder="Year" />
            </div>
            <div>
              <label>Zoom</label>
              <input id="timelineZoom" type="range" min="0.5" max="3" step="0.1" />
            </div>
            <button class="primary" id="btnTimelineApply">Apply</button>
          </div>
          <div class="timelineWrap">
            <div class="timelineScroller" id="timelineScroller">
              <div class="timelineInner" id="timelineInner">
                <div class="timelineAxis"></div>
                <div class="timelineEntries" id="timelineEntries"></div>
              </div>
            </div>
          </div>
          <div class="treeHint">
            Scroll to zoom, hover for glow, click an entry to edit them in the detail panel.
          </div>
        </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Theme Studio</summary>
      <div class="panelBody">
      <div class="row">
        <div>
          <label>Preset</label>
          <select id="themePreset"></select>
        </div>
        <div style="display:flex;gap:10px;align-items:flex-end">
          <button id="btnApplyPreset" class="primary">Apply Preset</button>
          <button id="btnResetTheme">Reset</button>
        </div>
      </div>
      <div class="themeGrid" id="themeGrid"></div>
      <div class="hint" style="margin-top:10px">
        Adjust colors to instantly re-skin the workspace and tree. Changes are saved locally.
      </div>
      </div>
    </details>

    <details class="panel" open>
      <summary class="panelSummary">Export / Import</summary>
      <div class="panelBody">

      <div class="split">
        <div>
          <label>Format</label>
          <select id="exportFormat">
            <option value="json">JSON (recommended)</option>
            <option value="yaml">YAML</option>
            <option value="dot">Graphviz DOT</option>
            <option value="mermaid">Mermaid (graph TD)</option>
            <option value="gedcom">GEDCOM (basic)</option>
          </select>
        </div>
        <div style="display:flex;gap:10px;align-items:flex-end">
          <button class="primary" id="btnExport">Generate Export</button>
          <button id="btnCopy">Copy</button>
          <button id="btnDownload">Download</button>
        </div>
      </div>

      <label>Export Output</label>
      <textarea id="out" class="mono" placeholder="Click ‚ÄúGenerate Export‚Äù ‚Ä¶"></textarea>

      <div class="hr"></div>

      <label>Import (JSON)</label>
      <textarea id="importBox" class="mono" placeholder='Paste JSON export here, then click ‚ÄúImport JSON‚Äù'></textarea>
      <div class="row">
        <button class="ok" id="btnImport">Import JSON</button>
        <button id="btnMergeImport">Merge JSON (keep existing)</button>
      </div>

      <div class="hint">
        <span class="warn">Note:</span> GEDCOM export is ‚Äúlite‚Äù (enough for many tools, but not full fidelity for fantasy calendars).
        For maximum interoperability, use JSON as your source of truth, then generate DOT/Mermaid for visuals.
      </div>
      </div>
    </details>
  </section>
</main>

<div class="modal" id="houseColorModal" aria-hidden="true">
  <div class="modalBackdrop" data-action="close-house-color"></div>
  <div class="modalPanel" role="dialog" aria-modal="true" aria-labelledby="houseColorTitle">
    <div class="modalHeader">
      <h2 class="modalTitle" id="houseColorTitle">Edit House Color</h2>
      <button id="houseColorClose">Close</button>
    </div>
    <div class="colorPreview" id="houseColorPreview"></div>
    <label>Hex</label>
    <input id="houseColorHex" placeholder="#AABBCC" class="mono" />
    <div class="row" style="margin-top:10px">
      <div>
        <label>Picker</label>
        <input type="color" id="houseColorPicker" />
      </div>
      <div>
        <label>Reset</label>
        <button id="houseColorReset">Default Palette</button>
      </div>
    </div>
    <div class="sectionTitle" style="margin-top:12px">RGB Sliders</div>
    <div class="sliderRow">
      <span>R</span>
      <input type="range" min="0" max="255" id="houseColorR" />
      <span id="houseColorRValue">0</span>
    </div>
    <div class="sliderRow">
      <span>G</span>
      <input type="range" min="0" max="255" id="houseColorG" />
      <span id="houseColorGValue">0</span>
    </div>
    <div class="sliderRow">
      <span>B</span>
      <input type="range" min="0" max="255" id="houseColorB" />
      <span id="houseColorBValue">0</span>
    </div>
    <div class="hint" style="margin-top:10px">
      Tip: Changes apply instantly to the tree and legend.
    </div>
  </div>
</div>

<script>
/** ===========================
 *  Data model
 *  ===========================
 *  store = {
 *    people: {
 *      [id]: {
 *        id, name, sex, birth, death, house,
 *        isRuler: boolean,
 *        titles: string[],
 *        notes: string,
 *        timelineValue: number | null,
 *        parents: string[],   // up to 2 typically, but we don't enforce
 *        partners: string[],  // spouses/partners
 *        children: string[],  // derived or manual; we keep it explicit for performance on large trees
 *        bloodlines: { [name]: number[] },
 *        bloodlinesAuto: boolean
 *      }
 *    },
 *    meta: { version, updatedAt, bloodlines, bloodlineSlots, bloodlineSettings }
 *  }
 */
const STORAGE_KEY = "wb_family_tree_v1";
const THEME_KEY = "wb_family_tree_theme_v1";
const HOUSE_COLOR_KEY = "wb_family_tree_house_colors_v1";
const EXPANDED_VIEW_KEY = "wb_family_tree_expanded_view_v1";
const VIEW_TAB_KEY = "wb_family_tree_view_tab_v1";
const BLOODLINE_DEFAULT_SLOTS = {};
const BLOODLINE_DEFAULT_SETTINGS = {
  mutationRate: 0.01,
  reinforcementRate: 0,
  latentThreshold: 0.6,
  enableLatent: false,
  totalStrengthCap: null
};
const DEFAULT_TIMELINE_SETTINGS = {
  start: 0,
  end: 100,
  step: 10,
  zoom: 1,
  unit: "Year"
};
const BLOODLINE_DEFAULT_DEFINITIONS = {};
let store = normalizeStore(loadStore() ?? freshStore());
let selectedId = null;
let sortMode = "name";
let currentTheme = loadTheme();
let houseColorOverrides = loadHouseColorOverrides();
let expandedView = loadExpandedView();
let activeViewTab = loadViewTab();
let editingBloodline = null;

function freshStore(){
  return {
    people: {},
    meta: withDefaultBloodlineMeta({ version: 2, updatedAt: new Date().toISOString() })
  };
}
function uid(){
  // short stable-ish id: p_ + 10 chars
  return "p_" + Math.random().toString(36).slice(2, 12);
}
function saveStore(){
  store.meta.updatedAt = new Date().toISOString();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
  render();
}
function loadStore(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    // basic shape check
    if(!parsed || typeof parsed !== "object" || !parsed.people) return null;
    return normalizeStore(parsed);
  }catch{ return null; }
}

function normalizeStore(candidate){
  if(!candidate || typeof candidate !== "object") return freshStore();
  const normalized = candidate;
  normalized.people = normalized.people || {};
  Object.values(normalized.people).forEach((person) => {
    person.isRuler = !!person.isRuler;
    person.titles = Array.isArray(person.titles) ? person.titles : [];
  });
  normalized.meta = withDefaultBloodlineMeta(normalized.meta || {});
  ["Drake", "Moon"].forEach((legacyName) => {
    if(normalized.meta?.bloodlines) delete normalized.meta.bloodlines[legacyName];
    if(normalized.meta?.bloodlineSlots) delete normalized.meta.bloodlineSlots[legacyName];
    Object.values(normalized.people).forEach((person) => {
      if(person?.bloodlines) delete person.bloodlines[legacyName];
    });
  });
  return normalized;
}

function withDefaultBloodlineMeta(meta){
  const next = { ...meta };
  next.version = next.version || 2;
  next.bloodlines = normalizeBloodlineDefinitions(next.bloodlines);
  const slotSource = next.bloodlineSlots || {};
  const mergedSlots = {
    ...BLOODLINE_DEFAULT_SLOTS,
    ...slotSource
  };
  Object.keys(next.bloodlines).forEach((name) => {
    if(!mergedSlots[name]) mergedSlots[name] = 12;
  });
  next.bloodlineSlots = mergedSlots;
  next.bloodlineSettings = {
    ...BLOODLINE_DEFAULT_SETTINGS,
    ...(next.bloodlineSettings || {})
  };
  next.timelineSettings = normalizeTimelineSettings(next.timelineSettings);
  return next;
}

function normalizeBloodlineDefinitions(definitions){
  const base = { ...BLOODLINE_DEFAULT_DEFINITIONS };
  if(!definitions || typeof definitions !== "object") return base;
  const result = { ...base };
  Object.entries(definitions).forEach(([key, value]) => {
    if(!key) return;
    const safe = value && typeof value === "object" ? value : {};
    result[key] = {
      name: safe.name || key,
      description: safe.description || "",
      notes: safe.notes || ""
    };
  });
  return result;
}

function normalizeTimelineSettings(settings){
  const base = { ...DEFAULT_TIMELINE_SETTINGS };
  if(!settings || typeof settings !== "object") return base;
  const next = { ...base, ...settings };
  const start = Number(next.start);
  const end = Number(next.end);
  const step = Number(next.step);
  const zoom = Number(next.zoom);
  return {
    start: Number.isFinite(start) ? start : base.start,
    end: Number.isFinite(end) ? end : base.end,
    step: Number.isFinite(step) && step > 0 ? step : base.step,
    zoom: Number.isFinite(zoom) && zoom > 0 ? zoom : base.zoom,
    unit: typeof next.unit === "string" && next.unit.trim() ? next.unit.trim() : base.unit
  };
}

function personById(id){ return store.people[id] || null; }

function getBloodlineSlots(){
  return store?.meta?.bloodlineSlots || { ...BLOODLINE_DEFAULT_SLOTS };
}

function getBloodlineSettings(){
  return store?.meta?.bloodlineSettings || { ...BLOODLINE_DEFAULT_SETTINGS };
}

function getBloodlineDefinitions(){
  return store?.meta?.bloodlines || normalizeBloodlineDefinitions(null);
}

function getTimelineSettings(){
  return store?.meta?.timelineSettings || normalizeTimelineSettings(null);
}

function updateTimelineSettings(patch, { save = true } = {}){
  const current = getTimelineSettings();
  store.meta.timelineSettings = normalizeTimelineSettings({
    ...current,
    ...patch
  });
  if(save) saveStore();
  else renderTimeline();
}

function updateBloodlineSlots(name, slots){
  const count = Math.max(1, Number(slots) || 0);
  store.meta.bloodlineSlots[name] = count;
  Object.values(store.people).forEach(person => {
    if(person.bloodlines && person.bloodlines[name]){
      person.bloodlines[name] = normalizeTokens(person.bloodlines[name], count);
    }
  });
}

function renameBloodline(oldName, nextName){
  if(oldName === nextName) return;
  const defs = store.meta.bloodlines;
  defs[nextName] = {
    name: nextName,
    description: defs[oldName]?.description || "",
    notes: defs[oldName]?.notes || ""
  };
  delete defs[oldName];
  if(store.meta.bloodlineSlots[oldName]){
    store.meta.bloodlineSlots[nextName] = store.meta.bloodlineSlots[oldName];
    delete store.meta.bloodlineSlots[oldName];
  }
  Object.values(store.people).forEach(person => {
    if(person.bloodlines && person.bloodlines[oldName]){
      person.bloodlines[nextName] = person.bloodlines[oldName];
      delete person.bloodlines[oldName];
    }
  });
}

function deleteBloodline(name){
  delete store.meta.bloodlines[name];
  delete store.meta.bloodlineSlots[name];
  Object.values(store.people).forEach(person => {
    if(person.bloodlines){
      delete person.bloodlines[name];
    }
  });
}

function defaultTheme(){
  return {
    name: "Obsidian Glow",
    values: {
      "--bg":"#0b0f14",
      "--panel":"#121923",
      "--panel2":"#0f151e",
      "--text":"#e7eef8",
      "--muted":"#9bb0c7",
      "--accent":"#6ee7ff",
      "--danger":"#ff6e8a",
      "--ok":"#7CFFA6",
      "--border":"#223145",
      "--tree-bg":"#0c131c",
      "--tree-glow":"rgba(110,231,255,.08)",
      "--node-bg":"#111827",
      "--node-stroke":"#334155",
      "--node-highlight":"#6ee7ff",
      "--node-text":"#e7eef8",
      "--node-sub":"#9bb0c7",
      "--edge":"#475569",
      "--partner":"#7c7c7c"
    }
  };
}

const themePresets = [
  defaultTheme(),
  {
    name: "Sunlit Canvas",
    values: {
      "--bg":"#f5f7fb",
      "--panel":"#ffffff",
      "--panel2":"#f0f3f8",
      "--text":"#1f2937",
      "--muted":"#5b6b7f",
      "--accent":"#2563eb",
      "--danger":"#dc2626",
      "--ok":"#16a34a",
      "--border":"#d6dde8",
      "--tree-bg":"#f1f5f9",
      "--tree-glow":"rgba(37,99,235,.12)",
      "--node-bg":"#ffffff",
      "--node-stroke":"#cbd5e1",
      "--node-highlight":"#2563eb",
      "--node-text":"#1f2937",
      "--node-sub":"#5b6b7f",
      "--edge":"#94a3b8",
      "--partner":"#94a3b8"
    }
  },
  {
    name: "Mist & Ink",
    values: {
      "--bg":"#eef1f6",
      "--panel":"#f9fafb",
      "--panel2":"#e5e9f1",
      "--text":"#1f2933",
      "--muted":"#526070",
      "--accent":"#0f766e",
      "--danger":"#b91c1c",
      "--ok":"#15803d",
      "--border":"#cbd4e1",
      "--tree-bg":"#e8edf4",
      "--tree-glow":"rgba(15,118,110,.14)",
      "--node-bg":"#ffffff",
      "--node-stroke":"#bcc7d6",
      "--node-highlight":"#0f766e",
      "--node-text":"#1f2933",
      "--node-sub":"#526070",
      "--edge":"#8b98aa",
      "--partner":"#8b98aa"
    }
  },
  {
    name: "Verdant Archive",
    values: {
      "--bg":"#0a0f0c",
      "--panel":"#111a14",
      "--panel2":"#0d1511",
      "--text":"#e6f2ea",
      "--muted":"#9bb7a2",
      "--accent":"#7efcc5",
      "--danger":"#ff8aa1",
      "--ok":"#9bffb5",
      "--border":"#1f3527",
      "--tree-bg":"#0d1511",
      "--tree-glow":"rgba(126,252,197,.10)",
      "--node-bg":"#111f17",
      "--node-stroke":"#2b4a36",
      "--node-highlight":"#7efcc5",
      "--node-text":"#e6f2ea",
      "--node-sub":"#9bb7a2",
      "--edge":"#3a5a46",
      "--partner":"#6fa988"
    }
  },
  {
    name: "Solar Ember",
    values: {
      "--bg":"#130b0b",
      "--panel":"#1b1110",
      "--panel2":"#150d0c",
      "--text":"#ffe9dc",
      "--muted":"#c8a79a",
      "--accent":"#ffb347",
      "--danger":"#ff7a7a",
      "--ok":"#ffd166",
      "--border":"#3d2420",
      "--tree-bg":"#170f0d",
      "--tree-glow":"rgba(255,179,71,.12)",
      "--node-bg":"#221211",
      "--node-stroke":"#56342b",
      "--node-highlight":"#ffb347",
      "--node-text":"#ffe9dc",
      "--node-sub":"#c8a79a",
      "--edge":"#7b4a3d",
      "--partner":"#b77b5d"
    }
  },
  {
    name: "Arcane Frost",
    values: {
      "--bg":"#0a0d13",
      "--panel":"#121823",
      "--panel2":"#0f141f",
      "--text":"#e9f1ff",
      "--muted":"#a5b8d6",
      "--accent":"#9ad0ff",
      "--danger":"#ff8fb1",
      "--ok":"#9af1ff",
      "--border":"#223147",
      "--tree-bg":"#0c111b",
      "--tree-glow":"rgba(154,208,255,.12)",
      "--node-bg":"#111825",
      "--node-stroke":"#2f3f57",
      "--node-highlight":"#9ad0ff",
      "--node-text":"#e9f1ff",
      "--node-sub":"#a5b8d6",
      "--edge":"#4a5b78",
      "--partner":"#7d90b5"
    }
  }
];

function loadTheme(){
  try{
    const raw = localStorage.getItem(THEME_KEY);
    if(!raw) return defaultTheme();
    const parsed = JSON.parse(raw);
    if(!parsed || !parsed.values) return defaultTheme();
    const base = defaultTheme();
    return {
      name: parsed.name || base.name,
      values: { ...base.values, ...parsed.values }
    };
  }catch{
    return defaultTheme();
  }
}

function saveTheme(){
  localStorage.setItem(THEME_KEY, JSON.stringify(currentTheme));
}

function loadExpandedView(){
  try{
    return localStorage.getItem(EXPANDED_VIEW_KEY) === "true";
  }catch{
    return false;
  }
}

function saveExpandedView(){
  localStorage.setItem(EXPANDED_VIEW_KEY, expandedView ? "true" : "false");
}

function loadViewTab(){
  try{
    return localStorage.getItem(VIEW_TAB_KEY) || "tree";
  }catch{
    return "tree";
  }
}

function saveViewTab(){
  try{
    localStorage.setItem(VIEW_TAB_KEY, activeViewTab);
  }catch{
    // ignore storage issues
  }
}

function applyTheme(theme){
  const root = document.documentElement;
  Object.entries(theme.values).forEach(([key, value]) => {
    root.style.setProperty(key, value);
  });
}

function loadHouseColorOverrides(){
  try{
    const raw = localStorage.getItem(HOUSE_COLOR_KEY);
    if(!raw) return {};
    const parsed = JSON.parse(raw);
    if(!parsed || typeof parsed !== "object") return {};
    return parsed;
  }catch{
    return {};
  }
}

function saveHouseColorOverrides(){
  localStorage.setItem(HOUSE_COLOR_KEY, JSON.stringify(houseColorOverrides));
}

function normalizeTitles(s){
  return (s || "")
    .split(",")
    .map(x => x.trim())
    .filter(Boolean);
}
function safeName(p){ return (p?.name || "").trim() || "(unnamed)"; }
function personEmoji(person){
  if(person?.sex === "M") return "‚ôÇÔ∏è";
  if(person?.sex === "F") return "‚ôÄÔ∏è";
  return "";
}

function parseTimelineInput(value){
  const trimmed = (value ?? "").toString().trim();
  if(!trimmed) return null;
  const num = Number(trimmed);
  return Number.isFinite(num) ? num : null;
}

function parseYearInput(value){
  const trimmed = (value ?? "").toString().trim();
  if(!trimmed) return null;
  const year = Number(trimmed);
  return Number.isFinite(year) ? year : null;
}

function extractNumericValue(text){
  const match = (text || "").toString().match(/-?\d+(?:\.\d+)?/);
  if(!match) return null;
  const num = Number(match[0]);
  return Number.isFinite(num) ? num : null;
}

function getLifeYears(person){
  return {
    birthYear: extractNumericValue(person?.birth),
    deathYear: extractNumericValue(person?.death)
  };
}

function getAgeAtDeath(person){
  const { birthYear, deathYear } = getLifeYears(person);
  if(!Number.isFinite(deathYear)) return null;
  if(!Number.isFinite(birthYear)) return null;
  return deathYear - birthYear;
}

function getAgeAtDeathLabel(person){
  const { deathYear } = getLifeYears(person);
  if(!Number.isFinite(deathYear)) return "N/A";
  const age = getAgeAtDeath(person);
  return Number.isFinite(age) ? String(age) : "--";
}

function getPersonTimelineValue(person){
  if(!person) return null;
  if(Number.isFinite(person.timelineValue)) return person.timelineValue;
  return extractNumericValue(person.birth);
}

function addPerson({
  name,
  sex,
  birth,
  death,
  timelineValue,
  house,
  isRuler = false,
  titles,
  notes,
  parents = [],
  bloodlineStrengths = null,
  rng = Math.random
}){
  const id = uid();
  const person = {
    id,
    name: (name || "").trim(),
    sex: sex || "",
    birth: birth || "",
    death: death || "",
    timelineValue: Number.isFinite(timelineValue) ? timelineValue : null,
    house: house || "",
    isRuler: !!isRuler,
    titles: titles || [],
    notes: notes || "",
    parents: [],
    partners: [],
    children: [],
    bloodlines: {},
    bloodlinesAuto: false
  };
  if(bloodlineStrengths && typeof bloodlineStrengths === "object"){
    person.bloodlines = seedBloodlinesFromStrengths(bloodlineStrengths, rng);
    person.bloodlinesAuto = false;
  }
  store.people[id] = person;
  if(Array.isArray(parents) && parents.length){
    parents.filter(Boolean).forEach(parentId => linkParentChild(parentId, id));
    applyBloodlinesFromParents(id);
  }
  return id;
}

function removeIdFromArray(arr, id){
  const i = arr.indexOf(id);
  if(i >= 0) arr.splice(i,1);
}

function linkParentChild(parentId, childId){
  const parent = personById(parentId);
  const child = personById(childId);
  if(!parent || !child) return;

  if(!parent.children.includes(childId)) parent.children.push(childId);
  if(!child.parents.includes(parentId)) child.parents.push(parentId);
  applyBloodlinesFromParents(childId);
}

function unlinkParentChild(parentId, childId){
  const parent = personById(parentId);
  const child = personById(childId);
  if(!parent || !child) return;

  removeIdFromArray(parent.children, childId);
  removeIdFromArray(child.parents, parentId);
}

function seedBloodlinesFromStrengths(strengths, rng = Math.random){
  const slots = getBloodlineSlots();
  const result = {};
  Object.entries(strengths || {}).forEach(([bloodline, strength]) => {
    const slotCount = slots[bloodline];
    if(!slotCount) return;
    result[bloodline] = createTokensFromStrength(strength, slotCount, rng);
  });
  return result;
}

function createTokensFromStrength(strength, slots, rng = Math.random){
  const clamped = Math.max(0, Math.min(1, Number(strength) || 0));
  const ones = Math.round(clamped * slots);
  const indices = [...Array(slots).keys()];
  shuffleInPlace(indices, rng);
  const tokens = Array(slots).fill(0);
  for(let i = 0; i < ones; i += 1){
    tokens[indices[i]] = 1;
  }
  return tokens;
}

function shuffleInPlace(arr, rng = Math.random){
  for(let i = arr.length - 1; i > 0; i -= 1){
    const j = Math.floor(rng() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function computeBloodlineStrength(tokens){
  if(!Array.isArray(tokens) || tokens.length === 0) return 0;
  const ones = tokens.reduce((sum, val) => sum + (val ? 1 : 0), 0);
  return ones / tokens.length;
}

function getBloodlineStrength(person, bloodline){
  return computeBloodlineStrength(person?.bloodlines?.[bloodline]);
}

function normalizeTokens(tokens, slots){
  const normalized = Array.isArray(tokens) ? tokens.slice(0, slots).map(v => (v ? 1 : 0)) : [];
  while(normalized.length < slots) normalized.push(0);
  return normalized;
}

function getBloodlineSlotCount(name, parentA, parentB){
  const slots = getBloodlineSlots();
  if(slots[name]) return slots[name];
  const tokensA = parentA?.bloodlines?.[name];
  const tokensB = parentB?.bloodlines?.[name];
  return tokensA?.length || tokensB?.length || null;
}

function inheritBloodlines({
  parentA,
  parentB,
  mutationRate = 0,
  reinforcementRate = 0,
  rng = Math.random
}){
  const names = new Set([
    ...Object.keys(getBloodlineSlots()),
    ...Object.keys(parentA?.bloodlines || {}),
    ...Object.keys(parentB?.bloodlines || {})
  ]);
  const result = {};
  for(const bloodline of names){
    const slotCount = getBloodlineSlotCount(bloodline, parentA, parentB);
    if(!slotCount) continue;
    const tokensA = parentA?.bloodlines?.[bloodline];
    const tokensB = parentB?.bloodlines?.[bloodline];
    if(!tokensA && !tokensB) continue;
    const parentTokensA = tokensA ? normalizeTokens(tokensA, slotCount) : Array(slotCount).fill(0);
    const parentTokensB = tokensB ? normalizeTokens(tokensB, slotCount) : Array(slotCount).fill(0);
    const childTokens = [];
    for(let i = 0; i < slotCount; i += 1){
      let inherited = rng() < 0.5 ? parentTokensA[i] : parentTokensB[i];
      if(reinforcementRate > 0 && parentTokensA[i] === 1 && parentTokensB[i] === 1 && rng() < reinforcementRate){
        inherited = 1;
      }
      if(mutationRate > 0 && rng() < mutationRate){
        inherited = inherited ? 0 : 1;
      }
      childTokens.push(inherited);
    }
    result[bloodline] = childTokens;
  }
  return result;
}

function hasBloodlines(person){
  return person && person.bloodlines && Object.keys(person.bloodlines).length > 0;
}

function applyBloodlinesFromParents(childId, { force = false } = {}){
  const child = personById(childId);
  if(!child) return;
  const parents = (child.parents || []).map(id => personById(id)).filter(Boolean);
  if(parents.length === 0) return;
  if(!force && hasBloodlines(child) && !child.bloodlinesAuto) return;
  const settings = getBloodlineSettings();
  const inherited = inheritBloodlines({
    parentA: parents[0] || null,
    parentB: parents[1] || null,
    mutationRate: settings.mutationRate,
    reinforcementRate: settings.reinforcementRate
  });
  if(Object.keys(inherited).length){
    child.bloodlines = inherited;
    child.bloodlinesAuto = true;
  }
}

function linkPartners(aId, bId){
  const a = personById(aId);
  const b = personById(bId);
  if(!a || !b || aId === bId) return;
  if(!a.partners.includes(bId)) a.partners.push(bId);
  if(!b.partners.includes(aId)) b.partners.push(aId);
}

function unlinkPartners(aId, bId){
  const a = personById(aId);
  const b = personById(bId);
  if(!a || !b) return;
  removeIdFromArray(a.partners, bId);
  removeIdFromArray(b.partners, aId);
}

function deletePerson(id){
  const p = personById(id);
  if(!p) return;

  // remove relationships from others
  for(const otherId of Object.keys(store.people)){
    const o = store.people[otherId];
    removeIdFromArray(o.parents, id);
    removeIdFromArray(o.children, id);
    removeIdFromArray(o.partners, id);
  }
  delete store.people[id];
  if(selectedId === id) selectedId = null;
}

/** ===========================
 *  Rendering
 *  =========================== */
const el = (id) => document.getElementById(id);

function render(){
  // count
  el("countPill").textContent = `${Object.keys(store.people).length} people`;

  // list
  renderPeopleList();

  // bloodlines
  renderBloodlineList();
  renderBloodlineLegend();

  // detail
  renderDetail();

  // expanded view
  applyExpandedView();

  // tree
  renderTree();

  // timeline
  renderTimeline();
}

function peopleArrayFiltered(){
  const q = (el("q").value || "").trim().toLowerCase();
  let arr = Object.values(store.people);

  if(q){
    arr = arr.filter(p => {
      const hay = [
        p.name, p.house, (p.titles||[]).join(" "), p.birth, p.death, p.notes
      ].join(" ").toLowerCase();
      return hay.includes(q);
    });
  }

  arr.sort((a,b) => {
    if(sortMode === "house"){
      const ha = (a.house||"").toLowerCase();
      const hb = (b.house||"").toLowerCase();
      if(ha !== hb) return ha.localeCompare(hb);
    }
    return safeName(a).toLowerCase().localeCompare(safeName(b).toLowerCase());
  });

  return arr;
}

function renderPeopleList(){
  const list = el("peopleList");
  list.innerHTML = "";

  const arr = peopleArrayFiltered();
  for(const p of arr){
    const div = document.createElement("div");
    div.className = "card";
    div.style.borderColor = (p.id === selectedId) ? "rgba(110,231,255,.45)" : "var(--border)";
    div.innerHTML = `
      <div class="cardTop">
        <div>
          <div class="name">${p.isRuler ? "üëë " : ""}${escapeHtml(safeName(p))} ${personEmoji(p)}</div>
          <div class="small">${escapeHtml(p.house || "")}${p.house && p.birth ? " ‚Ä¢ " : ""}${escapeHtml(p.birth || "")}</div>
          <div class="tags">
            ${(p.titles||[]).slice(0,6).map(t => `<span class="tag">${escapeHtml(t)}</span>`).join("")}
            ${(p.titles||[]).length>6 ? `<span class="tag">+${(p.titles||[]).length-6}</span>` : ""}
          </div>
        </div>
        <div style="display:flex;gap:8px">
          <button data-act="select" data-id="${p.id}">Select</button>
        </div>
      </div>
    `;
    div.querySelector('[data-act="select"]').onclick = () => { selectedId = p.id; render(); };
    list.appendChild(div);
  }

  if(arr.length === 0){
    list.innerHTML = `<div class="small">No results.</div>`;
  }
}

function renderBloodlineList(){
  const list = el("bloodlineList");
  if(!list) return;
  list.innerHTML = "";
  const defs = getBloodlineDefinitions();
  const slots = getBloodlineSlots();
  const names = Object.keys(defs).sort((a,b)=>a.localeCompare(b));
  if(names.length === 0){
    list.innerHTML = `<div class="small">No bloodlines yet.</div>`;
    return;
  }
  for(const name of names){
    const def = defs[name];
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="cardTop">
        <div>
          <div class="name">${escapeHtml(def.name || name)}</div>
          <div class="small">${escapeHtml(def.description || "")}</div>
        </div>
        <div style="display:flex;gap:8px">
          <button data-edit-bloodline="${escapeAttr(name)}">Edit</button>
          <button class="danger" data-delete-bloodline="${escapeAttr(name)}">Delete</button>
        </div>
      </div>
      <div class="kvs">
        <div class="kvk">Slots</div>
        <div class="kvv">${Number(slots[name] || 0)}</div>
        <div class="kvk">Notes</div>
        <div class="kvv">${escapeHtml(def.notes || "") || "‚Äî"}</div>
      </div>
    `;
    list.appendChild(card);
  }

  list.querySelectorAll("[data-edit-bloodline]").forEach(btn => {
    btn.onclick = () => {
      const name = btn.getAttribute("data-edit-bloodline");
      const def = defs[name];
      if(!def) return;
      editingBloodline = name;
      el("bloodlineName").value = def.name || name;
      el("bloodlineDesc").value = def.description || "";
      el("bloodlineNotes").value = def.notes || "";
      el("bloodlineSlots").value = String(slots[name] || 12);
      el("btnBloodlineSave").textContent = "Update Bloodline";
    };
  });
  list.querySelectorAll("[data-delete-bloodline]").forEach(btn => {
    btn.onclick = () => {
      const name = btn.getAttribute("data-delete-bloodline");
      if(!name) return;
      if(!confirm(`Delete bloodline "${name}"? This removes it from all people.`)) return;
      deleteBloodline(name);
      if(editingBloodline === name) resetBloodlineForm();
      saveStore();
    };
  });
}

function renderBloodlineLegend(){
  const legend = el("bloodlineLegend");
  if(!legend) return;
  const defs = getBloodlineDefinitions();
  const slots = getBloodlineSlots();
  const names = Object.keys(defs).sort((a,b)=>a.localeCompare(b));
  legend.innerHTML = "";
  if(names.length === 0){
    legend.innerHTML = `<div class="small">No bloodlines yet.</div>`;
    return;
  }
  for(const name of names){
    const def = defs[name];
    const item = document.createElement("div");
    item.className = "legendItem";
    item.innerHTML = `
      <span>${escapeHtml(def.name || name)}</span>
      <span class="tag">${Number(slots[name] || 0)} slots</span>
      <span class="small">${escapeHtml(def.description || "")}</span>
    `;
    legend.appendChild(item);
  }
}

function renderPersonBloodlines(person){
  const defs = getBloodlineDefinitions();
  const slots = getBloodlineSlots();
  const names = Object.keys(defs).sort((a,b)=>a.localeCompare(b));
  if(names.length === 0){
    return `<div class="small">No bloodlines defined yet.</div>`;
  }
  return names.map((name) => {
    const def = defs[name];
    const slotCount = Number(slots[name] || 0);
    const tokens = normalizeTokens(person.bloodlines?.[name], slotCount || 0);
    const activeCount = tokens.reduce((sum, val) => sum + (val ? 1 : 0), 0);
    const strength = slotCount ? Math.round((activeCount / slotCount) * 100) : 0;
    const tokenButtons = tokens.map((val, idx) => `
      <button
        type="button"
        class="token ${val ? "active" : ""}"
        data-bloodline-token="true"
        data-bloodline="${escapeAttr(name)}"
        data-token-index="${idx}"
        aria-pressed="${val ? "true" : "false"}"
        title="Toggle token ${idx + 1}"
      ></button>
    `).join("");
    return `
      <div class="card" style="margin-top:10px">
        <div class="cardTop">
          <div>
            <div class="name">${escapeHtml(def.name || name)}</div>
            <div class="small">${escapeHtml(def.description || "")}</div>
          </div>
          <div style="display:flex;gap:8px">
            <button data-clear-bloodline="${escapeAttr(name)}">Clear</button>
          </div>
        </div>
        <div class="tokenMeta">
          <span>${activeCount} / ${slotCount} tokens</span>
          <span>${strength}% strength</span>
        </div>
        <div class="tokenRow">${tokenButtons || `<span class="small">No slots configured.</span>`}</div>
        ${def.notes ? `<div class="small" style="margin-top:8px">${escapeHtml(def.notes)}</div>` : ""}
      </div>
    `;
  }).join("");
}

function renderDetail(){
  const panel = el("detailBody");
  const p = selectedId ? personById(selectedId) : null;
  if(!p){
    panel.innerHTML = `<div class="small">No person selected.</div>`;
    return;
  }

  // build dropdown options (exclude selected)
  const options = Object.values(store.people)
    .filter(x => x.id !== p.id)
    .sort((a,b)=>safeName(a).localeCompare(safeName(b)))
    .map(x => `<option value="${x.id}">${escapeHtml(safeName(x))}${x.house ? " ‚Äî " + escapeHtml(x.house) : ""}</option>`)
    .join("");

  const parents = (p.parents||[]).map(id => personById(id)).filter(Boolean);
  const partners = (p.partners||[]).map(id => personById(id)).filter(Boolean);
  const children = (p.children||[]).map(id => personById(id)).filter(Boolean);

  panel.innerHTML = `
    <div class="row">
      <div>
        <label>Name</label>
        <input id="eName" value="${escapeAttr(p.name)}" />
      </div>
      <div>
        <label>Sex/Gender</label>
        <select id="eSex">
          <option value="" ${p.sex===""?"selected":""}>(unspecified)</option>
          <option value="M" ${p.sex==="M"?"selected":""}>Male ‚ôÇÔ∏è</option>
          <option value="F" ${p.sex==="F"?"selected":""}>Female ‚ôÄÔ∏è</option>
          <option value="X" ${p.sex==="X"?"selected":""}>X / other</option>
        </select>
      </div>
    </div>
    <label class="inlineToggle" style="margin-top:4px">
      <input id="eRuler" type="checkbox" ${p.isRuler ? "checked" : ""} />
      Crown title (ruler/emperor) üëë
    </label>

    <div class="twoCol">
      <div>
        <label>Birth</label>
        <input id="eBirth" value="${escapeAttr(p.birth||"")}" />
      </div>
      <div>
        <label>Death</label>
        <input id="eDeath" value="${escapeAttr(p.death||"")}" />
      </div>
    </div>
    <div class="small">Age at death: ${escapeHtml(getAgeAtDeathLabel(p))}</div>

    <div class="row">
      <div>
        <label>Timeline Value (number)</label>
        <input id="eTimeline" type="number" step="any" value="${Number.isFinite(p.timelineValue) ? p.timelineValue : ""}" />
        <div class="small">Used for the timeline view; if blank, the first number in Birth is used.</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>House/Clan</label>
        <input id="eHouse" value="${escapeAttr(p.house||"")}" />
      </div>
      <div>
        <label>Titles (comma-separated)</label>
        <input id="eTitles" value="${escapeAttr((p.titles||[]).join(", "))}" />
      </div>
    </div>

    <label>Notes</label>
    <textarea id="eNotes">${escapeHtml(p.notes||"")}</textarea>

    <div class="row">
      <button class="ok" id="btnUpdate">Update</button>
      <button class="danger" id="btnDelete">Delete Person</button>
    </div>

    <div class="hr"></div>

    <div class="sectionTitle">Bloodlines</div>
    ${renderPersonBloodlines(p)}

    <div class="hr"></div>

    <div class="sectionTitle">Relationships</div>

    <div class="split">
      <div class="card" style="margin:0">
        <div class="name">Parents</div>
        <div class="small">${parents.length ? parents.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <select id="relParentSel"><option value="">Choose person‚Ä¶</option>${options}</select>
          <button id="btnAddParent">Add Parent</button>
        </div>
        <div style="margin-top:10px">
          ${parents.map(x => `
            <div class="row" style="align-items:center;margin-top:6px">
              <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
              <button data-unlink-parent="${x.id}" class="danger" style="flex:1">Remove</button>
            </div>
          `).join("")}
        </div>
      </div>

      <div class="card" style="margin:0">
        <div class="name">Partners</div>
        <div class="small">${partners.length ? partners.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>
        <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
          <select id="relPartnerSel"><option value="">Choose person‚Ä¶</option>${options}</select>
          <button id="btnAddPartner">Add Partner</button>
        </div>
        <div style="margin-top:10px">
          ${partners.map(x => `
            <div class="row" style="align-items:center;margin-top:6px">
              <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
              <button data-unlink-partner="${x.id}" class="danger" style="flex:1">Remove</button>
            </div>
          `).join("")}
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:10px">
      <div class="name">Children</div>
      <div class="small">${children.length ? children.map(x => escapeHtml(safeName(x))).join(", ") : "None"}</div>

      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
        <select id="relChildSel"><option value="">Choose person‚Ä¶</option>${options}</select>
        <button id="btnAddChild">Add Child</button>
      </div>

      <div style="margin-top:10px">
        ${children.map(x => `
          <div class="row" style="align-items:center;margin-top:6px">
            <div class="small" style="flex:2">${escapeHtml(safeName(x))}</div>
            <button data-unlink-child="${x.id}" class="danger" style="flex:1">Remove</button>
          </div>
        `).join("")}
      </div>

      <div class="hint" style="margin-top:10px">
        ‚ÄúAdd Child‚Äù links both ways (child ‚Üî parent). Same for parents and partners.
      </div>
    </div>
  `;

  // hook events
  el("btnUpdate").onclick = () => {
    const p2 = personById(p.id);
    if(!p2) return;
    p2.name = el("eName").value.trim();
    p2.sex = el("eSex").value;
    p2.birth = el("eBirth").value;
    p2.death = el("eDeath").value;
    p2.timelineValue = parseTimelineInput(el("eTimeline").value);
    p2.house = el("eHouse").value;
    p2.isRuler = !!el("eRuler").checked;
    p2.titles = normalizeTitles(el("eTitles").value);
    p2.notes = el("eNotes").value;
    saveStore();
  };

  el("btnDelete").onclick = () => {
    if(!confirm(`Delete ${safeName(p)}? This will remove their links too.`)) return;
    deletePerson(p.id);
    saveStore();
  };

  el("btnAddParent").onclick = () => {
    const other = el("relParentSel").value;
    if(!other) return;
    linkParentChild(other, p.id);
    saveStore();
  };

  el("btnAddChild").onclick = () => {
    const other = el("relChildSel").value;
    if(!other) return;
    linkParentChild(p.id, other);
    saveStore();
  };

  el("btnAddPartner").onclick = () => {
    const other = el("relPartnerSel").value;
    if(!other) return;
    linkPartners(p.id, other);
    saveStore();
  };

  panel.querySelectorAll("[data-unlink-parent]").forEach(btn => {
    btn.onclick = () => { unlinkParentChild(btn.getAttribute("data-unlink-parent"), p.id); saveStore(); };
  });
  panel.querySelectorAll("[data-unlink-child]").forEach(btn => {
    btn.onclick = () => { unlinkParentChild(p.id, btn.getAttribute("data-unlink-child")); saveStore(); };
  });
  panel.querySelectorAll("[data-unlink-partner]").forEach(btn => {
    btn.onclick = () => { unlinkPartners(p.id, btn.getAttribute("data-unlink-partner")); saveStore(); };
  });

  panel.querySelectorAll("[data-bloodline-token]").forEach(btn => {
    btn.onclick = () => {
      const name = btn.getAttribute("data-bloodline");
      const idx = Number(btn.getAttribute("data-token-index"));
      const slotCount = getBloodlineSlots()[name] || 0;
      if(!name || !Number.isFinite(idx) || slotCount <= 0) return;
      const tokens = normalizeTokens(p.bloodlines?.[name], slotCount);
      tokens[idx] = tokens[idx] ? 0 : 1;
      if(!p.bloodlines) p.bloodlines = {};
      p.bloodlines[name] = tokens;
      p.bloodlinesAuto = false;
      saveStore();
    };
  });

  panel.querySelectorAll("[data-clear-bloodline]").forEach(btn => {
    btn.onclick = () => {
      const name = btn.getAttribute("data-clear-bloodline");
      if(!name) return;
      if(p.bloodlines) delete p.bloodlines[name];
      p.bloodlinesAuto = false;
      saveStore();
    };
  });
}

function setActiveViewTab(tab){
  const next = tab === "timeline" ? "timeline" : "tree";
  activeViewTab = next;
  document.querySelectorAll("[data-view-tab]").forEach(btn => {
    btn.classList.toggle("active", btn.getAttribute("data-view-tab") === next);
  });
  document.querySelectorAll("[data-view-panel]").forEach(panel => {
    panel.classList.toggle("active", panel.getAttribute("data-view-panel") === next);
  });
  saveViewTab();
}

function escapeHtml(s){
  return (s ?? "").toString()
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}
function escapeAttr(s){
  return escapeHtml(s).replaceAll('"',"&quot;");
}

/** ===========================
 *  Timeline view
 *  =========================== */
function getTimelineEntries(){
  return Object.values(store.people)
    .map(person => {
      const value = getPersonTimelineValue(person);
      if(!Number.isFinite(value)) return null;
      return { person, value };
    })
    .filter(Boolean)
    .sort((a, b) => a.value - b.value);
}

function niceStepForRange(range){
  if(!Number.isFinite(range) || range <= 0) return 1;
  const raw = range / 6;
  const power = Math.pow(10, Math.floor(Math.log10(raw)));
  const scaled = raw / power;
  let nice = 10;
  if(scaled <= 1) nice = 1;
  else if(scaled <= 2) nice = 2;
  else if(scaled <= 5) nice = 5;
  return nice * power;
}

function renderTimeline(){
  const timelineInner = el("timelineInner");
  const timelineEntries = el("timelineEntries");
  if(!timelineInner || !timelineEntries) return;

  const settings = getTimelineSettings();
  const entries = getTimelineEntries();
  let start = settings.start;
  let end = settings.end;
  if(start > end){
    [start, end] = [end, start];
  }
  const step = settings.step;
  const unit = settings.unit;
  const zoom = settings.zoom;
  const pxPerUnit = 80 * zoom;
  const range = end - start;
  const safeRange = Number.isFinite(range) && range !== 0 ? range : 1;
  const width = Math.max(640, safeRange * pxPerUnit + 160);

  timelineInner.style.width = `${width}px`;
  timelineInner.style.minHeight = entries.length ? "240px" : "200px";

  const axis = timelineInner.querySelector(".timelineAxis");
  axis.style.left = "40px";
  axis.style.right = "40px";

  timelineInner.querySelectorAll(".timelineTick, .timelineTickLabel").forEach(node => node.remove());

  if(Number.isFinite(start) && Number.isFinite(end) && step > 0){
    for(let value = start; value <= end + step / 2; value += step){
      const left = (value - start) * pxPerUnit + 40;
      const tick = document.createElement("div");
      tick.className = "timelineTick";
      tick.style.left = `${left}px`;
      const label = document.createElement("div");
      label.className = "timelineTickLabel";
      label.style.left = `${left}px`;
      label.textContent = `${value}${unit ? " " + unit : ""}`;
      timelineInner.appendChild(tick);
      timelineInner.appendChild(label);
    }
  }

  timelineEntries.innerHTML = "";

  if(entries.length === 0){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.style.marginTop = "80px";
    empty.textContent = "No timeline data yet. Include a number in Birth.";
    timelineEntries.appendChild(empty);
  }else{
    const lanes = Math.min(4, Math.max(2, Math.ceil(entries.length / 6)));
    const laneHeight = 64;
    timelineInner.style.minHeight = `${120 + lanes * laneHeight}px`;
    entries.forEach((entry, idx) => {
      const lane = idx % lanes;
      const left = (entry.value - start) * pxPerUnit + 40;
      const top = 70 + lane * laneHeight;
      const button = document.createElement("button");
      button.type = "button";
      button.className = "timelineEntry";
      if(entry.person.id === selectedId) button.classList.add("is-selected");
      button.style.left = `${left}px`;
      button.style.top = `${top}px`;
      button.innerHTML = `
        <span class="timelineDot"></span>
        <span class="timelineContent">
          <span class="timelineName">${escapeHtml(safeName(entry.person))}</span>
          <span class="timelineMeta">${escapeHtml(entry.person.birth || "")}</span>
        </span>
      `;
      button.onclick = () => {
        selectedId = entry.person.id;
        render();
      };
      timelineEntries.appendChild(button);
    });
  }

  const timelineStatus = el("timelineStatus");
  if(timelineStatus){
    timelineStatus.textContent = `Zoom ${Math.round(zoom * 100)}%`;
  }

  const startInput = el("timelineStart");
  const endInput = el("timelineEnd");
  const stepInput = el("timelineStep");
  const unitInput = el("timelineUnit");
  const zoomInput = el("timelineZoom");
  if(startInput) startInput.value = Number.isFinite(start) ? start : "";
  if(endInput) endInput.value = Number.isFinite(end) ? end : "";
  if(stepInput) stepInput.value = Number.isFinite(step) ? step : "";
  if(unitInput) unitInput.value = unit || "";
  if(zoomInput) zoomInput.value = zoom;
}

function autoFitTimeline(){
  const entries = getTimelineEntries();
  if(entries.length === 0) return;
  const values = entries.map(entry => entry.value);
  let min = Math.min(...values);
  let max = Math.max(...values);
  if(min === max){
    min -= 5;
    max += 5;
  }
  const padding = (max - min) * 0.08;
  min -= padding;
  max += padding;
  const step = niceStepForRange(max - min);
  updateTimelineSettings({ start: min, end: max, step }, { save: true });
}

/** ===========================
 *  Tree view
 *  =========================== */
const treeView = {
  scale: 1,
  x: 0,
  y: 0,
  minScale: 0.4,
  maxScale: 2.4
};
const treeWrap = el("treeWrap");
const expandedToggle = el("expandedToggle");

function applyExpandedView(){
  if(treeWrap) treeWrap.classList.toggle("expanded", expandedView);
  if(expandedToggle) expandedToggle.checked = expandedView;
}

function updateTreeStatus(){
  el("treeStatus").textContent = `Zoom ${Math.round(treeView.scale * 100)}%`;
}

function applyTreeTransform(){
  const g = el("treeViewport");
  g.setAttribute("transform", `translate(${treeView.x} ${treeView.y}) scale(${treeView.scale})`);
  updateTreeStatus();
}

function clampTreeScale(next){
  return Math.min(treeView.maxScale, Math.max(treeView.minScale, next));
}

function clamp(min, max, value){
  return Math.min(max, Math.max(min, value));
}

function resetTreeView(){
  treeView.scale = 1;
  treeView.x = 0;
  treeView.y = 0;
  applyTreeTransform();
}

function buildPartnerGroups(people){
  const parent = new Map();
  const rank = new Map();
  const ids = people.map(p => p.id);
  ids.forEach(id => { parent.set(id, id); rank.set(id, 0); });

  const find = (id) => {
    const root = parent.get(id);
    if(root === id) return id;
    const next = find(root);
    parent.set(id, next);
    return next;
  };
  const union = (a, b) => {
    const ra = find(a);
    const rb = find(b);
    if(ra === rb) return;
    const rankA = rank.get(ra) || 0;
    const rankB = rank.get(rb) || 0;
    if(rankA < rankB) parent.set(ra, rb);
    else if(rankA > rankB) parent.set(rb, ra);
    else { parent.set(rb, ra); rank.set(ra, rankA + 1); }
  };

  for(const p of people){
    for(const partnerId of (p.partners||[])){
      if(store.people[partnerId]) union(p.id, partnerId);
    }
  }

  const groupMap = new Map();
  for(const id of ids){
    const root = find(id);
    if(!groupMap.has(root)) groupMap.set(root, []);
    groupMap.get(root).push(id);
  }

  const groupIdByPerson = new Map();
  const groups = [];
  let idx = 0;
  for(const members of groupMap.values()){
    const groupId = idx++;
    groups.push({ id: groupId, members });
    for(const member of members) groupIdByPerson.set(member, groupId);
  }

  return { groups, groupIdByPerson };
}

function computeGroupLevels(partnerGroups, people){
  const groupCount = partnerGroups.groups.length;
  const edges = new Map();
  const indegree = Array(groupCount).fill(0);
  for(let i=0;i<groupCount;i++) edges.set(i, new Set());

  for(const p of people){
    const fromGroup = partnerGroups.groupIdByPerson.get(p.id);
    for(const childId of (p.children||[])){
      if(!store.people[childId]) continue;
      const toGroup = partnerGroups.groupIdByPerson.get(childId);
      if(fromGroup === toGroup) continue;
      if(!edges.get(fromGroup).has(toGroup)){
        edges.get(fromGroup).add(toGroup);
        indegree[toGroup] += 1;
      }
    }
  }

  const levels = Array(groupCount).fill(0);
  const queue = [];
  indegree.forEach((deg, idx) => { if(deg === 0) queue.push(idx); });
  let visited = 0;
  while(queue.length){
    const g = queue.shift();
    visited += 1;
    for(const to of edges.get(g)){
      if(levels[to] < levels[g] + 1) levels[to] = levels[g] + 1;
      indegree[to] -= 1;
      if(indegree[to] === 0) queue.push(to);
    }
  }

  if(visited < groupCount){
    let changed = true;
    let iterations = 0;
    while(changed && iterations < groupCount * 4){
      changed = false;
      iterations += 1;
      for(const [from, targets] of edges.entries()){
        for(const to of targets){
          if(levels[to] < levels[from] + 1){
            levels[to] = levels[from] + 1;
            changed = true;
          }
        }
      }
    }
  }

  const result = new Map();
  partnerGroups.groups.forEach(group => {
    result.set(group.id, levels[group.id] || 0);
  });
  return result;
}

const housePalette = [
  "#60a5fa",
  "#f472b6",
  "#34d399",
  "#facc15",
  "#a78bfa",
  "#fb7185",
  "#22d3ee",
  "#fb923c",
  "#4ade80",
  "#f97316"
];

function hashString(str){
  let hash = 0;
  for(let i=0;i<str.length;i++){
    hash = (hash * 31 + str.charCodeAt(i)) | 0;
  }
  return Math.abs(hash);
}

function colorForHouse(house){
  const key = (house || "").trim();
  if(!key) return null;
  const idx = hashString(key) % housePalette.length;
  return housePalette[idx];
}

function resolveHouseColor(house){
  const key = (house || "").trim();
  if(!key) return null;
  if(houseColorOverrides[key]) return houseColorOverrides[key];
  return colorForHouse(key);
}

function renderTree(){
  const svg = el("treeSvg");
  const viewport = el("treeViewport");
  viewport.innerHTML = `<rect x="-6000" y="-6000" width="12000" height="12000" fill="transparent"></rect>`;

  const people = Object.values(store.people);
  if(people.length === 0){
    const text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute("x","0");
    text.setAttribute("y","0");
    text.setAttribute("class","nodeLabel");
    text.textContent = "Add people to see the tree.";
    viewport.appendChild(text);
    applyTreeTransform();
    return;
  }

  const nodeSize = { w: 180, h: 84, minGap: 56, gapY: 56 };
  const halfNode = nodeSize.w / 2;
  const peopleById = new Map(people.map(p => [p.id, p]));
  const personOrder = people.map(p => p.id);
  const personOrderRank = new Map(personOrder.map((id, idx) => [id, idx]));

  const parentsByChild = new Map();
  for(const p of people){
    for(const childId of (p.children || [])){
      if(!peopleById.has(childId)) continue;
      if(!parentsByChild.has(childId)) parentsByChild.set(childId, []);
      parentsByChild.get(childId).push(p.id);
    }
  }
  for(const parentIds of parentsByChild.values()){
    parentIds.sort((a, b) => (personOrderRank.get(a) ?? 0) - (personOrderRank.get(b) ?? 0));
  }

  const primaryParentByChild = new Map();
  for(const [childId, parentIds] of parentsByChild.entries()){
    if(parentIds.length) primaryParentByChild.set(childId, parentIds[0]);
  }

  const childrenByParent = new Map();
  for(const p of people){
    const orderedChildren = [];
    for(const childId of (p.children || [])){
      if(primaryParentByChild.get(childId) === p.id && peopleById.has(childId)){
        orderedChildren.push(childId);
      }
    }
    childrenByParent.set(p.id, orderedChildren);
  }

  const roots = people
    .filter(p => !primaryParentByChild.has(p.id))
    .map(p => p.id)
    .sort((a, b) => (personOrderRank.get(a) ?? 0) - (personOrderRank.get(b) ?? 0));
  if(roots.length === 0){
    roots.push(...personOrder);
  }

  const depthByPerson = new Map();
  const depthQueue = roots.map(id => ({ id, depth: 0 }));
  while(depthQueue.length){
    const { id, depth } = depthQueue.shift();
    const prevDepth = depthByPerson.get(id);
    if(prevDepth !== undefined && prevDepth <= depth) continue;
    depthByPerson.set(id, depth);
    const children = childrenByParent.get(id) || [];
    for(const childId of children){
      depthQueue.push({ id: childId, depth: depth + 1 });
    }
  }
  for(const p of people){
    if(!depthByPerson.has(p.id)) depthByPerson.set(p.id, 0);
  }

  const metricsByPerson = new Map();
  const childOffsetsByParent = new Map();
  const active = new Set();
  const computeSubtreeMetrics = (personId) => {
    if(metricsByPerson.has(personId)) return metricsByPerson.get(personId);
    if(active.has(personId)){
      return { leftExtent: -halfNode, rightExtent: halfNode, subtreeWidth: nodeSize.w };
    }
    active.add(personId);

    const childIds = childrenByParent.get(personId) || [];
    if(childIds.length === 0){
      const leaf = { leftExtent: -halfNode, rightExtent: halfNode, subtreeWidth: nodeSize.w };
      metricsByPerson.set(personId, leaf);
      childOffsetsByParent.set(personId, []);
      active.delete(personId);
      return leaf;
    }

    let leftExtent = -halfNode;
    let rightExtent = halfNode;
    const offsets = [];
    let prev = null;

    childIds.forEach((childId, idx) => {
      const childMetrics = computeSubtreeMetrics(childId);
      let centerX = 0;
      if(idx > 0 && prev){
        centerX = prev.centerX + prev.metrics.rightExtent + nodeSize.minGap - childMetrics.leftExtent;
      }
      offsets.push({ id: childId, x: centerX });
      leftExtent = Math.min(leftExtent, centerX + childMetrics.leftExtent);
      rightExtent = Math.max(rightExtent, centerX + childMetrics.rightExtent);
      prev = { centerX, metrics: childMetrics };
    });

    const metrics = {
      leftExtent,
      rightExtent,
      subtreeWidth: rightExtent - leftExtent
    };
    metricsByPerson.set(personId, metrics);
    childOffsetsByParent.set(personId, offsets);
    active.delete(personId);
    return metrics;
  };

  const positions = new Map();
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;

  const placeSubtree = (personId, centerX) => {
    const depth = depthByPerson.get(personId) || 0;
    const y = depth * (nodeSize.h + nodeSize.gapY);
    const x = centerX - halfNode;
    positions.set(personId, { x, y, subtreeWidth: metricsByPerson.get(personId)?.subtreeWidth || nodeSize.w });
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + nodeSize.w);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y + nodeSize.h);

    const childOffsets = childOffsetsByParent.get(personId) || [];
    for(const child of childOffsets){
      if(!positions.has(child.id)) placeSubtree(child.id, centerX + child.x);
    }
  };

  let prevRoot = null;
  for(const rootId of roots){
    const metrics = computeSubtreeMetrics(rootId);
    let rootCenterX = 0;
    if(prevRoot){
      rootCenterX = prevRoot.centerX + prevRoot.metrics.rightExtent + nodeSize.minGap - metrics.leftExtent;
    }
    placeSubtree(rootId, rootCenterX);
    prevRoot = { centerX: rootCenterX, metrics };
  }

  for(const p of people){
    if(!positions.has(p.id)){
      computeSubtreeMetrics(p.id);
      placeSubtree(p.id, prevRoot ? prevRoot.centerX + prevRoot.metrics.rightExtent + nodeSize.minGap - (metricsByPerson.get(p.id)?.leftExtent || -halfNode) : 0);
    }
  }

  const elbowPath = (start, end, mid) => {
    return `M ${start.x} ${start.y} L ${start.x} ${mid} L ${end.x} ${mid} L ${end.x} ${end.y}`;
  };

  const elbowPathByX = (start, end, midX) => {
    return `M ${start.x} ${start.y} L ${midX} ${start.y} L ${midX} ${end.y} L ${end.x} ${end.y}`;
  };

  // edges parent -> child
  for(const p of people){
    const from = positions.get(p.id);
    if(!from) continue;
    for(const childId of (p.children||[])){
      const to = positions.get(childId);
      if(!to) continue;
      const line = document.createElementNS("http://www.w3.org/2000/svg","path");
      const sx = from.x + nodeSize.w / 2;
      const sy = from.y + nodeSize.h;
      const tx = to.x + nodeSize.w / 2;
      const ty = to.y;
      const my = (sy + ty) / 2;
      line.setAttribute("d", elbowPath({ x: sx, y: sy }, { x: tx, y: ty }, my));
      line.setAttribute("class","edgeLine");
      viewport.appendChild(line);
    }
  }

  // partner lines
  for(const p of people){
    const from = positions.get(p.id);
    if(!from) continue;
    for(const partnerId of (p.partners||[])){
      if(partnerId <= p.id) continue;
      const to = positions.get(partnerId);
      if(!to) continue;
      const line = document.createElementNS("http://www.w3.org/2000/svg","path");
      const sx = from.x + nodeSize.w / 2;
      const sy = from.y + nodeSize.h / 2;
      const tx = to.x + nodeSize.w / 2;
      const ty = to.y + nodeSize.h / 2;
      if(Math.abs(ty - sy) < 1){
        line.setAttribute("d", `M ${sx} ${sy} L ${tx} ${ty}`);
      }else{
        const mx = (sx + tx) / 2;
        line.setAttribute("d", elbowPathByX({ x: sx, y: sy }, { x: tx, y: ty }, mx));
      }
      line.setAttribute("class","partnerLine");
      viewport.appendChild(line);
    }
  }

  const houseColors = new Map();
  for(const p of people){
    if(!p.house) continue;
    if(!houseColors.has(p.house)){
      houseColors.set(p.house, resolveHouseColor(p.house));
    }
  }

  // nodes
  for(const p of people){
    const pos = positions.get(p.id);
    if(!pos) continue;
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("data-id", p.id);
    g.setAttribute("transform", `translate(${pos.x} ${pos.y})`);

    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("width", nodeSize.w);
    rect.setAttribute("height", nodeSize.h);
    rect.setAttribute("rx","10");
    rect.setAttribute("class", `nodeCard ${p.id === selectedId ? "nodeHighlight" : ""}`);
    g.appendChild(rect);

    const houseColor = houseColors.get(p.house);
    if(houseColor){
      const accent = document.createElementNS("http://www.w3.org/2000/svg","rect");
      accent.setAttribute("x","0");
      accent.setAttribute("y","0");
      accent.setAttribute("width", nodeSize.w);
      accent.setAttribute("height","6");
      accent.setAttribute("rx","10");
      accent.setAttribute("fill", houseColor);
      g.appendChild(accent);
    }

    const name = document.createElementNS("http://www.w3.org/2000/svg","text");
    name.setAttribute("x","10");
    name.setAttribute("y","22");
    name.setAttribute("class","nodeLabel");
    name.textContent = `${p.isRuler ? "üëë " : ""}${safeName(p)} ${personEmoji(p)}`.trim();
    g.appendChild(name);

    if(p.house){
      const sub = document.createElementNS("http://www.w3.org/2000/svg","text");
      sub.setAttribute("x","10");
      sub.setAttribute("y","40");
      sub.setAttribute("class","nodeSub");
      sub.textContent = p.house;
      g.appendChild(sub);
    }

    if(p.titles && p.titles.length){
      const titles = document.createElementNS("http://www.w3.org/2000/svg","text");
      titles.setAttribute("x","10");
      titles.setAttribute("y","56");
      titles.setAttribute("class","nodeSub");
      titles.textContent = p.titles.join(", ");
      g.appendChild(titles);
    }

    if(p.birth || p.death){
      const life = document.createElementNS("http://www.w3.org/2000/svg","text");
      life.setAttribute("x","10");
      life.setAttribute("y", p.titles && p.titles.length ? "72" : "56");
      life.setAttribute("class","nodeSub");
      const lifespan = [p.birth || "", p.death ? `‚Äì ${p.death}` : ""].join(" ").trim();
      const ageLabel = getAgeAtDeathLabel(p);
      life.textContent = `${lifespan}${lifespan ? " ‚Ä¢ " : ""}Age: ${ageLabel}`;
      g.appendChild(life);
    }

    g.addEventListener("click", () => {
      selectedId = p.id;
      render();
    });

    viewport.appendChild(g);
  }

  const legend = el("treeLegend");
  if(legend){
    legend.innerHTML = "";
    const entries = Array.from(houseColors.entries()).sort((a,b)=>a[0].localeCompare(b[0]));
    if(entries.length === 0){
      legend.innerHTML = `<div class="small">No house categories yet.</div>`;
    }else{
      for(const [house, color] of entries){
        const item = document.createElement("button");
        item.type = "button";
        item.className = "legendItem legendButton";
        item.setAttribute("data-house", house);
        item.setAttribute("title", `Edit ${house} color`);
        const swatch = document.createElement("span");
        swatch.className = "legendSwatch";
        swatch.style.background = color;
        item.appendChild(swatch);
        const text = document.createElement("span");
        text.textContent = house;
        item.appendChild(text);
        legend.appendChild(item);
      }
    }
  }

  const centeredX = -((minX + maxX) / 2);
  const centeredY = -((minY + maxY) / 2);
  if(treeView.x === 0 && treeView.y === 0){
    treeView.x = centeredX;
    treeView.y = centeredY;
  }
  applyTreeTransform();
}

/** ===========================
 *  Export formats
 *  =========================== */

function exportJSON(){
  return JSON.stringify(store, null, 2);
}

function toYAML(obj, indent=0){
  const sp = "  ".repeat(indent);
  if(obj === null) return "null";
  if(typeof obj === "string"){
    // quote if needed
    if(obj === "" || /[:\n\-\{\}\[\],#&*!|>'"%@`]/.test(obj) || /^\s|\s$/.test(obj)){
      return JSON.stringify(obj); // safe quoting
    }
    return obj;
  }
  if(typeof obj === "number" || typeof obj === "boolean") return String(obj);
  if(Array.isArray(obj)){
    if(obj.length === 0) return "[]";
    return obj.map(v => `${sp}- ${toYAML(v, indent+1).replace(/^  /,"")}`).join("\n");
  }
  // object
  const keys = Object.keys(obj);
  if(keys.length === 0) return "{}";
  return keys.map(k => {
    const v = obj[k];
    if(v && typeof v === "object"){
      return `${sp}${k}:\n${toYAML(v, indent+1)}`;
    }else{
      return `${sp}${k}: ${toYAML(v, indent+1)}`;
    }
  }).join("\n");
}

function exportYAML(){
  return toYAML(store, 0);
}

function exportDOT(){
  // Directed edges: parent -> child
  // Partner edges: undirected-ish (we'll do dir=none)
  const lines = [];
  lines.push('digraph FamilyTree {');
  lines.push('  rankdir=TB;');
  lines.push('  node [shape=box, style="rounded,filled", fillcolor="#111827", color="#334155", fontcolor="#e5e7eb"];');
  lines.push('  edge [color="#64748b"];');

  // nodes
  for(const p of Object.values(store.people)){
    const label = [
      safeName(p),
      p.house ? `\\n${p.house}` : "",
      (p.titles && p.titles.length) ? `\\n(${p.titles.slice(0,3).join(", ")}${p.titles.length>3?"‚Ä¶":""})` : ""
    ].join("");
    lines.push(`  "${p.id}" [label="${escapeDot(label)}"];`);
  }

  // parent-child edges
  for(const p of Object.values(store.people)){
    for(const c of (p.children||[])){
      if(store.people[c]) lines.push(`  "${p.id}" -> "${c}";`);
    }
  }

  // partner edges
  lines.push('  // partners');
  for(const p of Object.values(store.people)){
    for(const partnerId of (p.partners||[])){
      if(partnerId > p.id) { // avoid duplicates with simple ordering
        if(store.people[partnerId]) lines.push(`  "${p.id}" -> "${partnerId}" [dir=none, style=dashed];`);
      }
    }
  }

  lines.push('}');
  return lines.join("\n");
}
function escapeDot(s){
  return (s ?? "").toString().replaceAll("\\","\\\\").replaceAll('"','\\"');
}

function exportMermaid(){
  // Mermaid graph TD
  // parent --> child; partner as --- (undirected) using --- is ok in flowcharts
  const lines = [];
  lines.push("graph TD");
  // nodes
  for(const p of Object.values(store.people)){
    const label = safeName(p) + (p.house ? `\\n${p.house}` : "");
    lines.push(`  ${p.id}["${escapeMermaid(label)}"]`);
  }
  // parent-child edges
  for(const p of Object.values(store.people)){
    for(const c of (p.children||[])){
      if(store.people[c]) lines.push(`  ${p.id} --> ${c}`);
    }
  }
  // partners
  lines.push("  %% partners (dashed)");
  for(const p of Object.values(store.people)){
    for(const partnerId of (p.partners||[])){
      if(partnerId > p.id && store.people[partnerId]){
        lines.push(`  ${p.id} -.-> ${partnerId}`);
      }
    }
  }
  return lines.join("\n");
}
function escapeMermaid(s){
  return (s ?? "").toString().replaceAll('"', '\\"');
}

function exportGEDCOM(){
  // Minimal GEDCOM 5.5-ish: INDI + FAM.
  // We'll generate FAM records for each partner pair and connect children when both parents are in that family.
  // If a child has multiple parents not in a partner pair, they'll still appear via FAM with first two parents found.
  const people = Object.values(store.people);
  const lines = [];
  lines.push("0 HEAD");
  lines.push("1 SOUR WorldbuildingFamilyTreeApp");
  lines.push("1 GEDC");
  lines.push("2 VERS 5.5");
  lines.push("1 CHAR UTF-8");
  lines.push("1 DATE " + new Date().toISOString().slice(0,10));

  // map person id -> GEDCOM @I#
  const indiId = new Map();
  people.forEach((p, idx) => indiId.set(p.id, `@I${idx+1}@`));

  // Build partner families
  const famKeys = new Set();
  const fams = []; // {key, aId, bId, children: []}
  function famKey(a,b){ return [a,b].sort().join("__"); }

  for(const p of people){
    for(const partner of (p.partners||[])){
      if(!store.people[partner]) continue;
      const key = famKey(p.id, partner);
      if(!famKeys.has(key)){
        famKeys.add(key);
        fams.push({ key, aId: p.id, bId: partner, children: [] });
      }
    }
  }

  // Add children to partner fam if child has both parents in that partner pair
  for(const fam of fams){
    const a = personById(fam.aId);
    const b = personById(fam.bId);
    if(!a || !b) continue;
    // children that appear in either parent's children list
    const cand = new Set([...(a.children||[]), ...(b.children||[])]);
    for(const cId of cand){
      const c = personById(cId);
      if(!c) continue;
      const hasA = (c.parents||[]).includes(a.id);
      const hasB = (c.parents||[]).includes(b.id);
      if(hasA && hasB) fam.children.push(cId);
    }
  }

  // For children with parents but no partner family, create a synthetic family with first 2 parents (or 1)
  const usedChild = new Set(fams.flatMap(f => f.children));
  for(const c of people){
    if((c.parents||[]).length === 0) continue;
    if(usedChild.has(c.id)) continue;
    const p1 = c.parents[0];
    const p2 = c.parents[1] || null;
    const key = famKey(p1, p2 || ("single__" + p1 + "__" + c.id));
    fams.push({ key, aId: p1, bId: p2, children: [c.id], synthetic: true });
  }

  // write INDI
  people.forEach(p => {
    lines.push(`0 ${indiId.get(p.id)} INDI`);
    lines.push(`1 NAME ${p.name || "?"}`);
    if(p.sex) lines.push(`1 SEX ${p.sex === "X" ? "U" : p.sex}`); // U for unknown/other-ish
    if(p.birth) {
      lines.push("1 BIRT");
      lines.push(`2 DATE ${p.birth}`);
    }
    if(p.death) {
      lines.push("1 DEAT");
      lines.push(`2 DATE ${p.death}`);
    }
    if(p.house) lines.push(`1 NOTE House/Clan: ${p.house}`);
    if(p.titles && p.titles.length) lines.push(`1 NOTE Titles: ${p.titles.join(", ")}`);
    if(p.notes) lines.push(`1 NOTE ${p.notes.replaceAll("\n"," ")}`);
  });

  // assign @F#
  const famId = new Map();
  fams.forEach((f, idx) => famId.set(f.key, `@F${idx+1}@`));

  // connect INDI to FAMS/FAMC
  // - spouses: FAMS
  // - children: FAMC for first matching family they appear in
  // We'll do a second pass and append these links by re-writing: easiest is to add them as NOTE-like blocks? We'll do it properly by emitting extra lines right after INDI, so we need indices‚Äîkeeping it simple: emit extra "1 FAMS/FAMC" immediately after creation by re-looping with computed matches.
  // We'll implement by building lookup maps and re-export in one pass with those lines included (so redo the INDI emission).
  lines.splice( lines.findIndex(x => x.startsWith("0 @I1@ INDI")), lines.length ); // remove INDI blocks we wrote
  // Re-add HEAD and then INDI with links.
  const head = [];
  head.push("0 HEAD");
  head.push("1 SOUR WorldbuildingFamilyTreeApp");
  head.push("1 GEDC");
  head.push("2 VERS 5.5");
  head.push("1 CHAR UTF-8");
  head.push("1 DATE " + new Date().toISOString().slice(0,10));
  lines.length = 0;
  lines.push(...head);

  // Build lookups
  const spouseFams = new Map(); // personId -> Set(famKey)
  const childFam = new Map();   // childId -> famKey
  for(const f of fams){
    if(f.aId && store.people[f.aId]){
      if(!spouseFams.has(f.aId)) spouseFams.set(f.aId, new Set());
      spouseFams.get(f.aId).add(f.key);
    }
    if(f.bId && store.people[f.bId]){
      if(!spouseFams.has(f.bId)) spouseFams.set(f.bId, new Set());
      spouseFams.get(f.bId).add(f.key);
    }
    for(const c of (f.children||[])){
      if(!childFam.has(c)) childFam.set(c, f.key);
    }
  }

  // emit INDI with links
  people.forEach(p => {
    lines.push(`0 ${indiId.get(p.id)} INDI`);
    lines.push(`1 NAME ${p.name || "?"}`);
    if(p.sex) lines.push(`1 SEX ${p.sex === "X" ? "U" : p.sex}`);
    // family links
    const famc = childFam.get(p.id);
    if(famc) lines.push(`1 FAMC ${famId.get(famc)}`);
    const famsSet = spouseFams.get(p.id);
    if(famsSet){
      for(const fk of famsSet){
        lines.push(`1 FAMS ${famId.get(fk)}`);
      }
    }
    if(p.birth) { lines.push("1 BIRT"); lines.push(`2 DATE ${p.birth}`); }
    if(p.death) { lines.push("1 DEAT"); lines.push(`2 DATE ${p.death}`); }
    if(p.house) lines.push(`1 NOTE House/Clan: ${p.house}`);
    if(p.titles && p.titles.length) lines.push(`1 NOTE Titles: ${p.titles.join(", ")}`);
    if(p.notes) lines.push(`1 NOTE ${p.notes.replaceAll("\n"," ")}`);
  });

  // emit FAM
  fams.forEach(f => {
    lines.push(`0 ${famId.get(f.key)} FAM`);
    if(f.aId && store.people[f.aId]) lines.push(`1 HUSB ${indiId.get(f.aId)}`);
    if(f.bId && store.people[f.bId]) lines.push(`1 WIFE ${indiId.get(f.bId)}`);
    for(const cId of (f.children||[])){
      if(store.people[cId]) lines.push(`1 CHIL ${indiId.get(cId)}`);
    }
    if(f.synthetic) lines.push(`1 NOTE Synthetic family (no explicit partnership)`);
  });

  lines.push("0 TRLR");
  return lines.join("\n");
}

function generateExport(){
  const fmt = el("exportFormat").value;
  let txt = "";
  if(fmt === "json") txt = exportJSON();
  else if(fmt === "yaml") txt = exportYAML();
  else if(fmt === "dot") txt = exportDOT();
  else if(fmt === "mermaid") txt = exportMermaid();
  else if(fmt === "gedcom") txt = exportGEDCOM();
  el("out").value = txt;
}

/** ===========================
 *  Import
 *  =========================== */
function importJSON({ merge }){
  const raw = el("importBox").value.trim();
  if(!raw) return alert("Paste JSON first.");
  let parsed;
  try{ parsed = JSON.parse(raw); }
  catch{ return alert("Invalid JSON."); }

  if(!parsed || typeof parsed !== "object" || !parsed.people){
    return alert("JSON doesn't look like an export from this app (missing people).");
  }

  if(!merge){
    store = normalizeStore(parsed);
    selectedId = null;
    saveStore();
    return;
  }

  // merge: keep existing, add new ids; if conflict, rename incoming id
  const incomingPeople = parsed.people || {};
  for(const [id, p] of Object.entries(incomingPeople)){
    let newId = id;
    while(store.people[newId]) newId = uid();

    // clone and rewrite internal links if id changed
    const cloned = JSON.parse(JSON.stringify(p));
    cloned.id = newId;

    // remap references when id changes: we only remap self-id; other ids are left as-is (best-effort)
    if(newId !== id){
      // if any other incoming person refers to old id, that won't be fixed here (complex).
      // We'll at least keep this person consistent internally.
    }

    store.people[newId] = cloned;
  }
  saveStore();
  alert("Merged. Note: references between imported records aren‚Äôt fully remapped when IDs collide. Use non-merge import for perfect fidelity.");
}

/** ===========================
 *  Wire UI
 *  =========================== */
function syncCreatePersonAgeFields(changedField = ""){
  const birthInput = el("pBirth");
  const deathInput = el("pDeath");
  const ageInput = el("pAgeAtDeath");
  const aliveInput = el("pAlive");
  if(!birthInput || !deathInput || !ageInput || !aliveInput) return;

  const isAlive = aliveInput.checked;
  deathInput.disabled = isAlive;
  ageInput.disabled = isAlive;

  if(isAlive){
    deathInput.value = "";
    ageInput.value = "";
    return;
  }

  let birthYear = parseYearInput(birthInput.value);
  let deathYear = parseYearInput(deathInput.value);
  let ageAtDeath = parseYearInput(ageInput.value);

  if(changedField === "birth"){
    if(Number.isFinite(birthYear) && Number.isFinite(deathYear)) ageAtDeath = deathYear - birthYear;
    else if(Number.isFinite(birthYear) && Number.isFinite(ageAtDeath)) deathYear = birthYear + ageAtDeath;
  }else if(changedField === "death"){
    if(Number.isFinite(birthYear) && Number.isFinite(deathYear)) ageAtDeath = deathYear - birthYear;
    else if(Number.isFinite(deathYear) && Number.isFinite(ageAtDeath)) birthYear = deathYear - ageAtDeath;
  }else if(changedField === "age"){
    if(Number.isFinite(birthYear) && Number.isFinite(ageAtDeath)) deathYear = birthYear + ageAtDeath;
    else if(Number.isFinite(deathYear) && Number.isFinite(ageAtDeath)) birthYear = deathYear - ageAtDeath;
  }

  if(Number.isFinite(birthYear) && Number.isFinite(deathYear) && !Number.isFinite(ageAtDeath)) ageAtDeath = deathYear - birthYear;
  if(Number.isFinite(birthYear) && Number.isFinite(ageAtDeath) && !Number.isFinite(deathYear)) deathYear = birthYear + ageAtDeath;
  if(Number.isFinite(deathYear) && Number.isFinite(ageAtDeath) && !Number.isFinite(birthYear)) birthYear = deathYear - ageAtDeath;

  birthInput.value = Number.isFinite(birthYear) ? String(birthYear) : "";
  deathInput.value = Number.isFinite(deathYear) ? String(deathYear) : "";
  ageInput.value = Number.isFinite(ageAtDeath) ? String(ageAtDeath) : "";
}

function getCreatePersonLifeData(){
  const birthYear = parseYearInput(el("pBirth").value);
  const deathYear = parseYearInput(el("pDeath").value);
  const alive = !!el("pAlive").checked;
  return {
    birth: Number.isFinite(birthYear) ? String(birthYear) : "",
    death: (!alive && Number.isFinite(deathYear)) ? String(deathYear) : ""
  };
}

el("btnAdd").onclick = () => {
  const name = el("pName").value.trim();
  if(!name) return alert("Name is required.");
  const lifeData = getCreatePersonLifeData();
  addPerson({
    name,
    sex: el("pSex").value,
    birth: lifeData.birth,
    death: lifeData.death,
    house: el("pHouse").value,
    isRuler: !!el("pRuler").checked,
    titles: normalizeTitles(el("pTitles").value),
    notes: el("pNotes").value
  });
  clearCreateForm();
  saveStore();
};

el("btnAddAndSelect").onclick = () => {
  const name = el("pName").value.trim();
  if(!name) return alert("Name is required.");
  const lifeData = getCreatePersonLifeData();
  const id = addPerson({
    name,
    sex: el("pSex").value,
    birth: lifeData.birth,
    death: lifeData.death,
    house: el("pHouse").value,
    isRuler: !!el("pRuler").checked,
    titles: normalizeTitles(el("pTitles").value),
    notes: el("pNotes").value
  });
  clearCreateForm();
  selectedId = id;
  saveStore();
};

el("btnBloodlineSave").onclick = () => {
  const name = el("bloodlineName").value.trim();
  if(!name) return alert("Bloodline name is required.");
  const description = el("bloodlineDesc").value.trim();
  const notes = el("bloodlineNotes").value.trim();
  const slotsInput = Number(el("bloodlineSlots").value);
  const defs = getBloodlineDefinitions();
  const previous = editingBloodline;
  if(previous && previous !== name && defs[name]){
    return alert("A bloodline with that name already exists.");
  }
  if(previous && previous !== name){
    renameBloodline(previous, name);
  }
  store.meta.bloodlines[name] = {
    name,
    description,
    notes
  };
  const fallbackSlots = getBloodlineSlots()[name] || 12;
  updateBloodlineSlots(name, slotsInput || fallbackSlots);
  resetBloodlineForm();
  saveStore();
};

el("btnBloodlineReset").onclick = () => resetBloodlineForm();

function clearCreateForm(){
  el("pName").value = "";
  el("pSex").value = "";
  el("pBirth").value = "";
  el("pDeath").value = "";
  el("pAgeAtDeath").value = "";
  el("pAlive").checked = false;
  el("pRuler").checked = false;
  el("pHouse").value = "";
  el("pTitles").value = "";
  el("pNotes").value = "";
  syncCreatePersonAgeFields();
}

function resetBloodlineForm(){
  editingBloodline = null;
  el("bloodlineName").value = "";
  el("bloodlineDesc").value = "";
  el("bloodlineNotes").value = "";
  el("bloodlineSlots").value = "";
  el("btnBloodlineSave").textContent = "Add Bloodline";
}

el("pBirth").addEventListener("input", () => syncCreatePersonAgeFields("birth"));
el("pDeath").addEventListener("input", () => syncCreatePersonAgeFields("death"));
el("pAgeAtDeath").addEventListener("input", () => syncCreatePersonAgeFields("age"));
el("pAlive").addEventListener("change", () => syncCreatePersonAgeFields("alive"));
syncCreatePersonAgeFields();

el("q").addEventListener("input", () => renderPeopleList());
el("btnSortName").onclick = () => { sortMode = "name"; renderPeopleList(); };
el("btnSortHouse").onclick = () => { sortMode = "house"; renderPeopleList(); };

el("btnExport").onclick = generateExport;

el("btnCopy").onclick = async () => {
  const txt = el("out").value;
  if(!txt) return;
  try{
    await navigator.clipboard.writeText(txt);
    alert("Copied!");
  }catch{
    alert("Copy failed (browser restriction). Select and copy manually.");
  }
};

el("btnDownload").onclick = () => {
  const txt = el("out").value;
  if(!txt) return alert("Generate export first.");
  const fmt = el("exportFormat").value;
  const ext = fmt === "json" ? "json"
            : fmt === "yaml" ? "yml"
            : fmt === "dot" ? "dot"
            : fmt === "mermaid" ? "mmd"
            : "ged";
  const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `family_tree_export.${ext}`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
};

el("btnImport").onclick = () => importJSON({ merge:false });
el("btnMergeImport").onclick = () => importJSON({ merge:true });

el("btnSave").onclick = () => saveStore();

el("btnReset").onclick = () => {
  if(!confirm("Reset will erase the saved tree in this browser. Continue?")) return;
  store = freshStore();
  selectedId = null;
  saveStore();
};

el("btnApplyPreset").onclick = () => {
  const presetIndex = Number(el("themePreset").value);
  const preset = themePresets[presetIndex];
  if(!preset) return;
  currentTheme = JSON.parse(JSON.stringify(preset));
  applyTheme(currentTheme);
  saveTheme();
  renderThemeControls();
};

el("btnResetTheme").onclick = () => {
  currentTheme = defaultTheme();
  applyTheme(currentTheme);
  saveTheme();
  renderThemeControls();
};

document.querySelectorAll("[data-view-tab]").forEach(btn => {
  btn.addEventListener("click", () => {
    setActiveViewTab(btn.getAttribute("data-view-tab"));
  });
});
setActiveViewTab(activeViewTab);

el("btnTimelineApply").onclick = () => {
  const current = getTimelineSettings();
  const nextStart = parseTimelineInput(el("timelineStart").value);
  const nextEnd = parseTimelineInput(el("timelineEnd").value);
  const nextStep = parseTimelineInput(el("timelineStep").value);
  const unitValue = el("timelineUnit").value;
  updateTimelineSettings({
    start: nextStart ?? current.start,
    end: nextEnd ?? current.end,
    step: nextStep ?? current.step,
    unit: unitValue || current.unit
  });
};

el("btnTimelineAuto").onclick = () => autoFitTimeline();

el("timelineZoom").addEventListener("input", (event) => {
  const nextZoom = Number(event.target.value);
  updateTimelineSettings({ zoom: nextZoom }, { save: false });
});

el("timelineZoom").addEventListener("change", (event) => {
  const nextZoom = Number(event.target.value);
  updateTimelineSettings({ zoom: nextZoom }, { save: true });
});

const timelineScroller = el("timelineScroller");
if(timelineScroller){
  timelineScroller.addEventListener("wheel", (event) => {
    if(!event.ctrlKey) return;
    event.preventDefault();
    const direction = Math.sign(event.deltaY);
    const current = getTimelineSettings().zoom;
    const next = Math.max(0.5, Math.min(3, current + (direction > 0 ? -0.1 : 0.1)));
    updateTimelineSettings({ zoom: next }, { save: true });
  }, { passive: false });
}

/** ===========================
 *  Tree interactions
 *  =========================== */
const treeSvg = el("treeSvg");
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let pinchStartDistance = null;
let pinchStartScale = 1;

if(expandedToggle){
  expandedToggle.addEventListener("change", (event) => {
    expandedView = event.target.checked;
    applyExpandedView();
    saveExpandedView();
  });
}

el("btnZoomIn").onclick = () => {
  const rect = treeSvg.getBoundingClientRect();
  zoomTreeAt(getSvgPoint(rect.left + rect.width / 2, rect.top + rect.height / 2), treeView.scale + 0.15);
};
el("btnZoomOut").onclick = () => {
  const rect = treeSvg.getBoundingClientRect();
  zoomTreeAt(getSvgPoint(rect.left + rect.width / 2, rect.top + rect.height / 2), treeView.scale - 0.15);
};
el("btnZoomReset").onclick = () => resetTreeView();

treeSvg.addEventListener("wheel", (event) => {
  event.preventDefault();
  const direction = Math.sign(event.deltaY);
  const next = treeView.scale + (direction > 0 ? -0.1 : 0.1);
  const point = getSvgPoint(event.clientX, event.clientY);
  zoomTreeAt(point, next);
}, { passive: false });

treeSvg.addEventListener("mousedown", (event) => {
  isDragging = true;
  dragStart = { x: event.clientX - treeView.x, y: event.clientY - treeView.y };
  treeSvg.classList.add("dragging");
});
window.addEventListener("mousemove", (event) => {
  if(!isDragging) return;
  treeView.x = event.clientX - dragStart.x;
  treeView.y = event.clientY - dragStart.y;
  applyTreeTransform();
});
window.addEventListener("mouseup", () => {
  isDragging = false;
  treeSvg.classList.remove("dragging");
});

treeSvg.addEventListener("touchstart", (event) => {
  if(event.touches.length === 1){
    const touch = event.touches[0];
    isDragging = true;
    dragStart = { x: touch.clientX - treeView.x, y: touch.clientY - treeView.y };
    treeSvg.classList.add("dragging");
  }else if(event.touches.length === 2){
    isDragging = false;
    treeSvg.classList.remove("dragging");
    pinchStartDistance = getTouchDistance(event.touches[0], event.touches[1]);
    pinchStartScale = treeView.scale;
  }
}, { passive: false });

treeSvg.addEventListener("touchmove", (event) => {
  if(event.touches.length === 1 && isDragging){
    const touch = event.touches[0];
    treeView.x = touch.clientX - dragStart.x;
    treeView.y = touch.clientY - dragStart.y;
    applyTreeTransform();
    event.preventDefault();
  }else if(event.touches.length === 2){
    const t1 = event.touches[0];
    const t2 = event.touches[1];
    const nextDistance = getTouchDistance(t1, t2);
    if(pinchStartDistance){
      const nextScale = pinchStartScale * (nextDistance / pinchStartDistance);
      const midpoint = {
        x: (t1.clientX + t2.clientX) / 2,
        y: (t1.clientY + t2.clientY) / 2
      };
      zoomTreeAt(getSvgPoint(midpoint.x, midpoint.y), nextScale);
    }
    event.preventDefault();
  }
}, { passive: false });

treeSvg.addEventListener("touchend", (event) => {
  if(event.touches.length === 0){
    isDragging = false;
    treeSvg.classList.remove("dragging");
    pinchStartDistance = null;
  }else if(event.touches.length === 1){
    const touch = event.touches[0];
    isDragging = true;
    dragStart = { x: touch.clientX - treeView.x, y: touch.clientY - treeView.y };
  }
});

treeSvg.addEventListener("touchcancel", () => {
  isDragging = false;
  treeSvg.classList.remove("dragging");
  pinchStartDistance = null;
});

function autosave(){
  // lightweight: saving on most mutations is already handled via saveStore()
  el("status").textContent = "Autosave: on ‚Ä¢ Last updated: " + (store.meta.updatedAt ? store.meta.updatedAt.slice(0,19).replace("T"," ") : "‚Äî");
}
setInterval(autosave, 1200);

function colorToHex(value){
  if(!value) return "#000000";
  if(value.startsWith("#")) return value;
  const rgba = value.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
  if(!rgba) return "#000000";
  const r = Number(rgba[1]).toString(16).padStart(2, "0");
  const g = Number(rgba[2]).toString(16).padStart(2, "0");
  const b = Number(rgba[3]).toString(16).padStart(2, "0");
  return `#${r}${g}${b}`;
}

function hexToRgba(hex, alpha){
  const raw = hex.replace("#", "");
  if(raw.length !== 6) return hex;
  const r = parseInt(raw.slice(0,2), 16);
  const g = parseInt(raw.slice(2,4), 16);
  const b = parseInt(raw.slice(4,6), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function normalizeHex(value){
  if(!value) return null;
  const trimmed = value.trim();
  const hex = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
  if(!/^#([0-9a-f]{6})$/i.test(hex)) return null;
  return hex.toUpperCase();
}

function hexToRgb(hex){
  const raw = hex.replace("#", "");
  return {
    r: parseInt(raw.slice(0,2), 16),
    g: parseInt(raw.slice(2,4), 16),
    b: parseInt(raw.slice(4,6), 16)
  };
}

function rgbToHex({ r, g, b }){
  const toHex = (val) => Math.max(0, Math.min(255, val)).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
}

function getSvgPoint(clientX, clientY){
  const pt = treeSvg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const matrix = treeSvg.getScreenCTM();
  if(!matrix) return { x: clientX, y: clientY };
  const result = pt.matrixTransform(matrix.inverse());
  return { x: result.x, y: result.y };
}

function zoomTreeAt(point, nextScale){
  const clamped = clampTreeScale(nextScale);
  const prevScale = treeView.scale;
  const prevX = treeView.x;
  const prevY = treeView.y;
  const screenX = point.x * prevScale + prevX;
  const screenY = point.y * prevScale + prevY;
  treeView.scale = clamped;
  treeView.x = screenX - point.x * clamped;
  treeView.y = screenY - point.y * clamped;
  applyTreeTransform();
}

function getTouchDistance(t1, t2){
  const dx = t1.clientX - t2.clientX;
  const dy = t1.clientY - t2.clientY;
  return Math.hypot(dx, dy);
}

function renderThemeControls(){
  const presetSelect = el("themePreset");
  presetSelect.innerHTML = "";
  themePresets.forEach((preset, idx) => {
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = preset.name;
    presetSelect.appendChild(opt);
  });
  const matchIndex = themePresets.findIndex(preset => preset.name === currentTheme.name);
  presetSelect.value = matchIndex >= 0 ? String(matchIndex) : "0";

  const themeFields = [
    { label: "Background", key: "--bg" },
    { label: "Panel", key: "--panel" },
    { label: "Panel Alt", key: "--panel2" },
    { label: "Text", key: "--text" },
    { label: "Muted", key: "--muted" },
    { label: "Accent", key: "--accent" },
    { label: "Danger", key: "--danger" },
    { label: "Success", key: "--ok" },
    { label: "Border", key: "--border" },
    { label: "Tree BG", key: "--tree-bg" },
    { label: "Tree Glow", key: "--tree-glow", glow: true },
    { label: "Node BG", key: "--node-bg" },
    { label: "Node Stroke", key: "--node-stroke" },
    { label: "Node Highlight", key: "--node-highlight" },
    { label: "Node Text", key: "--node-text" },
    { label: "Node Subtext", key: "--node-sub" },
    { label: "Edge", key: "--edge" },
    { label: "Partner", key: "--partner" }
  ];

  const grid = el("themeGrid");
  grid.innerHTML = "";
  themeFields.forEach(field => {
    const wrapper = document.createElement("div");
    wrapper.className = "themeField";
    const label = document.createElement("span");
    label.textContent = field.label;
    const input = document.createElement("input");
    input.type = "color";
    const rawValue = currentTheme.values[field.key] || "";
    input.value = colorToHex(rawValue);
    input.addEventListener("input", (event) => {
      const value = event.target.value;
      currentTheme.name = "Custom";
      currentTheme.values[field.key] = field.glow ? hexToRgba(value, 0.12) : value;
      applyTheme(currentTheme);
      saveTheme();
    });
    wrapper.appendChild(label);
    wrapper.appendChild(input);
    grid.appendChild(wrapper);
  });
}

applyTheme(currentTheme);
renderThemeControls();
render();

const houseColorModal = el("houseColorModal");
const houseColorTitle = el("houseColorTitle");
const houseColorPreview = el("houseColorPreview");
const houseColorHex = el("houseColorHex");
const houseColorPicker = el("houseColorPicker");
const houseColorR = el("houseColorR");
const houseColorG = el("houseColorG");
const houseColorB = el("houseColorB");
const houseColorRValue = el("houseColorRValue");
const houseColorGValue = el("houseColorGValue");
const houseColorBValue = el("houseColorBValue");
const houseColorClose = el("houseColorClose");
const houseColorReset = el("houseColorReset");
let activeHouse = null;
let updatingHouseControls = false;

function openHouseColorModal(house){
  activeHouse = house;
  houseColorTitle.textContent = `Edit ${house} color`;
  const base = resolveHouseColor(house) || "#FFFFFF";
  updateHouseControls(base);
  houseColorModal.classList.add("is-open");
  houseColorModal.setAttribute("aria-hidden", "false");
}

function closeHouseColorModal(){
  activeHouse = null;
  houseColorModal.classList.remove("is-open");
  houseColorModal.setAttribute("aria-hidden", "true");
}

function updateHouseControls(color){
  const hex = normalizeHex(color) || "#FFFFFF";
  const rgb = hexToRgb(hex);
  updatingHouseControls = true;
  houseColorPreview.style.background = hex;
  houseColorHex.value = hex;
  houseColorPicker.value = hex;
  houseColorR.value = String(rgb.r);
  houseColorG.value = String(rgb.g);
  houseColorB.value = String(rgb.b);
  houseColorRValue.textContent = String(rgb.r);
  houseColorGValue.textContent = String(rgb.g);
  houseColorBValue.textContent = String(rgb.b);
  updatingHouseControls = false;
}

function applyHouseColor(hex){
  if(!activeHouse) return;
  const normalized = normalizeHex(hex);
  if(!normalized) return;
  houseColorOverrides[activeHouse] = normalized;
  saveHouseColorOverrides();
  updateHouseControls(normalized);
  renderTree();
}

function resetHouseColor(){
  if(!activeHouse) return;
  delete houseColorOverrides[activeHouse];
  saveHouseColorOverrides();
  const fallback = resolveHouseColor(activeHouse) || "#FFFFFF";
  updateHouseControls(fallback);
  renderTree();
}

houseColorHex.addEventListener("input", (event) => {
  if(updatingHouseControls) return;
  const normalized = normalizeHex(event.target.value);
  if(!normalized) return;
  applyHouseColor(normalized);
});

houseColorPicker.addEventListener("input", (event) => {
  if(updatingHouseControls) return;
  applyHouseColor(event.target.value);
});

[houseColorR, houseColorG, houseColorB].forEach(input => {
  input.addEventListener("input", () => {
    if(updatingHouseControls) return;
    const rgb = {
      r: Number(houseColorR.value),
      g: Number(houseColorG.value),
      b: Number(houseColorB.value)
    };
    const hex = rgbToHex(rgb);
    applyHouseColor(hex);
  });
});

houseColorClose.onclick = () => closeHouseColorModal();
houseColorReset.onclick = () => resetHouseColor();
houseColorModal.addEventListener("click", (event) => {
  if(event.target.matches('[data-action="close-house-color"]')) closeHouseColorModal();
});

document.addEventListener("click", (event) => {
  const target = event.target.closest(".legendButton");
  if(!target) return;
  const house = target.getAttribute("data-house");
  if(house) openHouseColorModal(house);
});
</script>
</body>
</html>
